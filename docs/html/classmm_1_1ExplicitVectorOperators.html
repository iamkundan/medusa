<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medusa: mm::ExplicitVectorOperators&lt; shape_storage_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Medusa"/>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      dpar: ["\\frac{\\partial #1}{\\partial #2}", 2]
    }
  }
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://e6.ijs.si/medusa/"><img alt="Logo" src="logo_transparent.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
    <div id="projectname">Medusa
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">Coordinate Free Mehless Method implementation</div>
  </td>
   <td id="ijslogo"><a href="http://e6.ijs.si/ParallelAndDistributedSystems/"><img src="logo_ijs.png" alt="IJS_logo"></a></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.php','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmm_1_1ExplicitVectorOperators.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmm_1_1ExplicitVectorOperators-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mm::ExplicitVectorOperators&lt; shape_storage_type &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__operators.html">Operators</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>&gt;<br />
class mm::ExplicitVectorOperators&lt; shape_storage_type &gt;</div><p>A class for evaluating typical operators needed in spatial discretization. </p>
<p>This class represents vector differential operators, discretely approximated with shape functions that are stored in given shape storage. These shape functions are used to construct approximations of common operators such as gradient, Laplacian, divergence, ... that can be applied to vector fields at given points.</p>
<dl class="section note"><dt>Note</dt><dd>The scalar types (and sometimes even dimensions) of the given fields and the shapes can be different. We support computing the gradient of a <code>3d</code> complex-valued field over 2d domain with <code>double</code> shapes: the result is a <code>3x2</code> complex matrix.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">shape_storage_type</td><td>Storage class for shapes. Must satisfy the <a class="el" href="concepts.html#ss-concept">Shape storage concept</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classmm_1_1Gaussian.html">BoxShape&lt;Vec2d&gt;</a> <a class="code hl_class" href="classmm_1_1Gaussian.html">box</a>({0.0, 0.0}, {1.0, 1.0});</div>
<div class="line">    DomainDiscretization&lt;Vec2d&gt; d = box.discretizeWithStep(0.02);</div>
<div class="line">    d.findSupport(FindClosest(9));</div>
<div class="line">    WLS&lt;Monomials&lt;Vec2d&gt;, NoWeight&lt;Vec2d&gt;, ScaleToFarthest&gt; wls(2);</div>
<div class="line">    <span class="keyword">auto</span> storage = d.computeShapes(wls);</div>
<div class="line">    <a class="code hl_function" href="classmm_1_1ExplicitVectorOperators.html#a3b786fc4844851f6257c1df8d11861b5">ExplicitVectorOperators</a>&lt;<span class="keyword">decltype</span>(storage)&gt; op(storage);</div>
<div class="line">    std::cout &lt;&lt; op &lt;&lt; std::endl;</div>
<div class="line">    <a class="code hl_typedef" href="namespacemm.html#a73a915a34cc600397408fd67f7dcf500">VectorField2d</a> v(d.size());  <span class="comment">// constant scalar field, value 1.34 at each point</span></div>
<div class="line">    v = <a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a>(12.4, -3.4);</div>
<div class="line">    <a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a> val = op.lap(v, 2);  <span class="comment">// laplace at point d.pos(2);</span></div>
<div class="line">    Eigen::Matrix2d <a class="code hl_function" href="classmm_1_1ExplicitVectorOperators.html#a64160803e909a0f8dde8b1c0af75d28c">grad</a> = op.grad(v, 4);  <span class="comment">// gradient at point d.pos(4);</span></div>
<div class="line">    <span class="keywordtype">double</span> <a class="code hl_function" href="classmm_1_1ExplicitVectorOperators.html#ad97e967fc33fd3618d9c248fe5d661bc">div</a> = op.div(v, 3);  <span class="comment">// divergence at points d.pos(3);</span></div>
<div class="line"> </div>
<div class="line">    VectorField&lt;std::complex&lt;double&gt;, 3&gt; complex_field(d.size());  <span class="comment">// 3d complex field</span></div>
<div class="line">    complex_field.setConstant(std::complex&lt;double&gt;(2.5, -7.1));</div>
<div class="line">    Eigen::Matrix&lt;std::complex&lt;double&gt;, 3, 2&gt; cgrad = op.grad(complex_field, 1);</div>
<div class="ttc" id="aclassmm_1_1ExplicitVectorOperators_html_a3b786fc4844851f6257c1df8d11861b5"><div class="ttname"><a href="classmm_1_1ExplicitVectorOperators.html#a3b786fc4844851f6257c1df8d11861b5">mm::ExplicitVectorOperators::ExplicitVectorOperators</a></div><div class="ttdeci">ExplicitVectorOperators()</div><div class="ttdoc">Construct empty explicit vector operators.</div><div class="ttdef"><b>Definition</b> <a href="ExplicitVectorOperators__fwd_8hpp_source.html#l00052">ExplicitVectorOperators_fwd.hpp:52</a></div></div>
<div class="ttc" id="aclassmm_1_1ExplicitVectorOperators_html_a64160803e909a0f8dde8b1c0af75d28c"><div class="ttname"><a href="classmm_1_1ExplicitVectorOperators.html#a64160803e909a0f8dde8b1c0af75d28c">mm::ExplicitVectorOperators::grad</a></div><div class="ttdeci">Eigen::Matrix&lt; typename vector_type&lt; vector_field_t &gt;::type::scalar_t, vector_type&lt; vector_field_t &gt;::type::dim, dim &gt; grad(const vector_field_t &amp;u, int node) const</div><div class="ttdoc">Returns gradient of vector field u in node with index node.</div></div>
<div class="ttc" id="aclassmm_1_1ExplicitVectorOperators_html_ad97e967fc33fd3618d9c248fe5d661bc"><div class="ttname"><a href="classmm_1_1ExplicitVectorOperators.html#ad97e967fc33fd3618d9c248fe5d661bc">mm::ExplicitVectorOperators::div</a></div><div class="ttdeci">vector_type&lt; vector_field_t &gt;::type::scalar_t div(const vector_field_t &amp;u, int node) const</div><div class="ttdoc">Returns divergence of a vector field u in in node with index node.</div></div>
<div class="ttc" id="aclassmm_1_1Gaussian_html"><div class="ttname"><a href="classmm_1_1Gaussian.html">mm::Gaussian</a></div><div class="ttdoc">Gaussian Radial Basis Function.</div><div class="ttdef"><b>Definition</b> <a href="Gaussian__fwd_8hpp_source.html#l00029">Gaussian_fwd.hpp:29</a></div></div>
<div class="ttc" id="anamespacemm_html_a3cf09fb5c30d93f0cfb30d80f0b8c6cf"><div class="ttname"><a href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">mm::Vec2d</a></div><div class="ttdeci">Vec&lt; double, 2 &gt; Vec2d</div><div class="ttdoc">Convenience typedef for 2d vector of doubles.</div><div class="ttdef"><b>Definition</b> <a href="Vec__fwd_8hpp_source.html#l00034">Vec_fwd.hpp:34</a></div></div>
<div class="ttc" id="anamespacemm_html_a73a915a34cc600397408fd67f7dcf500"><div class="ttname"><a href="namespacemm.html#a73a915a34cc600397408fd67f7dcf500">mm::VectorField2d</a></div><div class="ttdeci">VectorField&lt; double, 2 &gt; VectorField2d</div><div class="ttdoc">Two dimensional vector field of doubles.</div><div class="ttdef"><b>Definition</b> <a href="VectorField__fwd_8hpp_source.html#l00152">VectorField_fwd.hpp:152</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmm_1_1ExplicitOperators.html" title="A class for evaluating typical operators needed in spatial discretization.">ExplicitOperators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html#l00038">38</a> of file <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b786fc4844851f6257c1df8d11861b5" id="r_a3b786fc4844851f6257c1df8d11861b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#a3b786fc4844851f6257c1df8d11861b5">ExplicitVectorOperators</a> ()</td></tr>
<tr class="memdesc:a3b786fc4844851f6257c1df8d11861b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty explicit vector operators.  <br /></td></tr>
<tr class="separator:a3b786fc4844851f6257c1df8d11861b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc62adeb0f8d059ce76ca2ba75937d9" id="r_a4bc62adeb0f8d059ce76ca2ba75937d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#a4bc62adeb0f8d059ce76ca2ba75937d9">ExplicitVectorOperators</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html#aa4ec090148a0102f47f398502aecd0f3">shape_storage_t</a> &amp;<a class="el" href="classmm_1_1ExplicitVectorOperators.html#ae710a528a03642c6e49efd0b89c00e86">ss</a>)</td></tr>
<tr class="memdesc:a4bc62adeb0f8d059ce76ca2ba75937d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct explicit vector operators over given shape storage.  <br /></td></tr>
<tr class="separator:a4bc62adeb0f8d059ce76ca2ba75937d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac095f65178d4b654eaa5443a010c8e8c" id="r_ac095f65178d4b654eaa5443a010c8e8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#ac095f65178d4b654eaa5443a010c8e8c">setShapes</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html#aa4ec090148a0102f47f398502aecd0f3">shape_storage_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">shape_storage_</a>)</td></tr>
<tr class="memdesc:ac095f65178d4b654eaa5443a010c8e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new shape storage from which this operators are generated.  <br /></td></tr>
<tr class="separator:ac095f65178d4b654eaa5443a010c8e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d951546bbba14d287f721aca7f570b4" id="r_a7d951546bbba14d287f721aca7f570b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#a7d951546bbba14d287f721aca7f570b4">hasShapes</a> () <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:a7d951546bbba14d287f721aca7f570b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if operators have a non-null pointer to storage and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:a7d951546bbba14d287f721aca7f570b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35c038ad0bce86f6337c51297b864f1" id="r_ac35c038ad0bce86f6337c51297b864f1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </td></tr>
<tr class="memitem:ac35c038ad0bce86f6337c51297b864f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#ac35c038ad0bce86f6337c51297b864f1">lap</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">u</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> node) <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:ac35c038ad0bce86f6337c51297b864f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Laplacian of vector field <code>u</code> in node with index <code>node</code>.  <br /></td></tr>
<tr class="separator:ac35c038ad0bce86f6337c51297b864f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59e210d9c8d912822fb8ce6ad2941d0" id="r_ab59e210d9c8d912822fb8ce6ad2941d0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> , <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </td></tr>
<tr class="memitem:ab59e210d9c8d912822fb8ce6ad2941d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#ab59e210d9c8d912822fb8ce6ad2941d0">apply</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">u</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">typename</a> op_family_t::operator_t o) <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:ab59e210d9c8d912822fb8ce6ad2941d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximation of applying the requested operator to each component of field <code>u</code> at node <code>node</code>.  <br /></td></tr>
<tr class="separator:ab59e210d9c8d912822fb8ce6ad2941d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d3a5655713416c9e283990851a5805" id="r_aa5d3a5655713416c9e283990851a5805"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> , <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </td></tr>
<tr class="memitem:aa5d3a5655713416c9e283990851a5805"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#aa5d3a5655713416c9e283990851a5805">apply</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">u</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> node) <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:aa5d3a5655713416c9e283990851a5805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for default constructible operator.  <br /></td></tr>
<tr class="separator:aa5d3a5655713416c9e283990851a5805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64160803e909a0f8dde8b1c0af75d28c" id="r_a64160803e909a0f8dde8b1c0af75d28c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </td></tr>
<tr class="memitem:a64160803e909a0f8dde8b1c0af75d28c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type::scalar_t, <a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type::dim, <a class="el" href="classmm_1_1ExplicitVectorOperators.html#a702f59361f77601ac71b4bec82f2a8b0a2ba4d29e16c8448be2c2a820ae287c27">dim</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#a64160803e909a0f8dde8b1c0af75d28c">grad</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">u</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> node) <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:a64160803e909a0f8dde8b1c0af75d28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns gradient of vector field <code>u</code> in node with index <code>node</code>.  <br /></td></tr>
<tr class="separator:a64160803e909a0f8dde8b1c0af75d28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97e967fc33fd3618d9c248fe5d661bc" id="r_ad97e967fc33fd3618d9c248fe5d661bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </td></tr>
<tr class="memitem:ad97e967fc33fd3618d9c248fe5d661bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type::scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#ad97e967fc33fd3618d9c248fe5d661bc">div</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">u</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> node) <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:ad97e967fc33fd3618d9c248fe5d661bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns divergence of a vector field <code>u</code> in in node with index <code>node</code>.  <br /></td></tr>
<tr class="separator:ad97e967fc33fd3618d9c248fe5d661bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88a56b20e9e71045c6dccc597b3a693" id="r_af88a56b20e9e71045c6dccc597b3a693"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </td></tr>
<tr class="memitem:af88a56b20e9e71045c6dccc597b3a693"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#af88a56b20e9e71045c6dccc597b3a693">curl</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">u</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> node) <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:af88a56b20e9e71045c6dccc597b3a693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns curl of a vector field <code>u</code> in node with index <code>node</code>.  <br /></td></tr>
<tr class="separator:af88a56b20e9e71045c6dccc597b3a693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d104b88923f76168e394a58a6a5f66" id="r_a04d104b88923f76168e394a58a6a5f66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </td></tr>
<tr class="memitem:a04d104b88923f76168e394a58a6a5f66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#a04d104b88923f76168e394a58a6a5f66">graddiv</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">u</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> node) <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:a04d104b88923f76168e394a58a6a5f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns gradient of divergence of a vector field <code>u</code> in in node with index <code>node</code>.  <br /></td></tr>
<tr class="separator:a04d104b88923f76168e394a58a6a5f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa92529f4a97a9573aeeff7032c8c40a" id="r_afa92529f4a97a9573aeeff7032c8c40a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </td></tr>
<tr class="memitem:afa92529f4a97a9573aeeff7032c8c40a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#afa92529f4a97a9573aeeff7032c8c40a">neumann</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">u</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html#a56df5a558e2406073d5f41203daa8d61">vector_t</a> &amp;normal, <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type <a class="el" href="classmm_1_1Gaussian.html">val</a>) <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:afa92529f4a97a9573aeeff7032c8c40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a vectorised version of <a class="el" href="classmm_1_1ExplicitOperators.html#af6db62a3f8104330369f04dda0781c29" title="Calculates a new field value a for u at node, such that the Neumann boundary condition du/dn(node) = ...">ExplicitOperators::neumann</a>.  <br /></td></tr>
<tr class="separator:afa92529f4a97a9573aeeff7032c8c40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a702f59361f77601ac71b4bec82f2a8b0" id="r_a702f59361f77601ac71b4bec82f2a8b0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classmm_1_1ExplicitVectorOperators.html#a702f59361f77601ac71b4bec82f2a8b0a2ba4d29e16c8448be2c2a820ae287c27">dim</a> = shape_storage_t::dim
 }</td></tr>
<tr class="memdesc:a702f59361f77601ac71b4bec82f2a8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store dimension of the domain.  <a href="classmm_1_1ExplicitVectorOperators.html#a702f59361f77601ac71b4bec82f2a8b0">More...</a><br /></td></tr>
<tr class="separator:a702f59361f77601ac71b4bec82f2a8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ec090148a0102f47f398502aecd0f3" id="r_aa4ec090148a0102f47f398502aecd0f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">typedef</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#aa4ec090148a0102f47f398502aecd0f3">shape_storage_t</a></td></tr>
<tr class="memdesc:aa4ec090148a0102f47f398502aecd0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of shape storage.  <br /></td></tr>
<tr class="separator:aa4ec090148a0102f47f398502aecd0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56df5a558e2406073d5f41203daa8d61" id="r_a56df5a558e2406073d5f41203daa8d61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">typedef</a> shape_storage_t::vector_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#a56df5a558e2406073d5f41203daa8d61">vector_t</a></td></tr>
<tr class="memdesc:a56df5a558e2406073d5f41203daa8d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type.  <br /></td></tr>
<tr class="separator:a56df5a558e2406073d5f41203daa8d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc38469fb9e8b5fe09f06a03e349a95" id="r_a0fc38469fb9e8b5fe09f06a03e349a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">typedef</a> <a class="el" href="classmm_1_1Gaussian.html#a485cc39648f69212e4c1bcef60e0f194">shape_storage_t::scalar_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#a0fc38469fb9e8b5fe09f06a03e349a95">scalar_t</a></td></tr>
<tr class="memdesc:a0fc38469fb9e8b5fe09f06a03e349a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type.  <br /></td></tr>
<tr class="separator:a0fc38469fb9e8b5fe09f06a03e349a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5f6cf04c1f5af921a3f186003656ef73" id="r_a5f6cf04c1f5af921a3f186003656ef73"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">S</a> &gt; </td></tr>
<tr class="memitem:a5f6cf04c1f5af921a3f186003656ef73"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#a5f6cf04c1f5af921a3f186003656ef73">operator&lt;&lt;</a> (std::ostream &amp;<a class="el" href="classmm_1_1Gaussian.html">os</a>, <a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html">ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">S</a> &gt; &amp;op)</td></tr>
<tr class="memdesc:a5f6cf04c1f5af921a3f186003656ef73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output basic info about given operators.  <br /></td></tr>
<tr class="separator:a5f6cf04c1f5af921a3f186003656ef73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae710a528a03642c6e49efd0b89c00e86" id="r_ae710a528a03642c6e49efd0b89c00e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html#aa4ec090148a0102f47f398502aecd0f3">shape_storage_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ExplicitVectorOperators.html#ae710a528a03642c6e49efd0b89c00e86">ss</a></td></tr>
<tr class="memdesc:ae710a528a03642c6e49efd0b89c00e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to shape storage, but name is shortened for readability.  <br /></td></tr>
<tr class="separator:ae710a528a03642c6e49efd0b89c00e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a702f59361f77601ac71b4bec82f2a8b0" name="a702f59361f77601ac71b4bec82f2a8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702f59361f77601ac71b4bec82f2a8b0">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">anonymous</a> <a class="el" href="classmm_1_1Gaussian.html">enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store dimension of the domain. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a702f59361f77601ac71b4bec82f2a8b0a2ba4d29e16c8448be2c2a820ae287c27" name="a702f59361f77601ac71b4bec82f2a8b0a2ba4d29e16c8448be2c2a820ae287c27"></a>dim&#160;</td><td class="fielddoc"><p>Dimensionality of the function domain. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html#l00044">44</a> of file <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3b786fc4844851f6257c1df8d11861b5" name="a3b786fc4844851f6257c1df8d11861b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b786fc4844851f6257c1df8d11861b5">&#9670;&#160;</a></span>ExplicitVectorOperators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::ExplicitVectorOperators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct empty explicit vector operators. </p>

<p class="definition">Definition at line <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html#l00052">52</a> of file <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a4bc62adeb0f8d059ce76ca2ba75937d9" name="a4bc62adeb0f8d059ce76ca2ba75937d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc62adeb0f8d059ce76ca2ba75937d9">&#9670;&#160;</a></span>ExplicitVectorOperators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::ExplicitVectorOperators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html#aa4ec090148a0102f47f398502aecd0f3">shape_storage_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct explicit vector operators over given shape storage. </p>
<p>The pointer to given storage is stored as a non-owning pointer. It is the user's responsibility that given storage is valid throughout the use use of this class.</p>
<p>This class is usually constructed directly from shape storage using the <code>explicitVectorOperators()</code> member function. </p>

<p class="definition">Definition at line <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html#l00061">61</a> of file <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa5d3a5655713416c9e283990851a5805" name="aa5d3a5655713416c9e283990851a5805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d3a5655713416c9e283990851a5805">&#9670;&#160;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> , <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for default constructible operator. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmm_1_1ExplicitVectorOperators.html#ab59e210d9c8d912822fb8ce6ad2941d0" title="Returns an approximation of applying the requested operator to each component of field u at node node...">apply</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html#l00110">110</a> of file <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="ab59e210d9c8d912822fb8ce6ad2941d0" name="ab59e210d9c8d912822fb8ce6ad2941d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59e210d9c8d912822fb8ce6ad2941d0">&#9670;&#160;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> , <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">typename</a> op_family_t::operator_t&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximation of applying the requested operator to each component of field <code>u</code> at node <code>node</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Field to which the operator is applied. </td></tr>
    <tr><td class="paramname">node</td><td>Node at which the derived field is evaluated. </td></tr>
    <tr><td class="paramname">o</td><td>The operator to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The operator approximation is obtained from shape storage using the <code>op_family_t</code> type. The first weights computed for family of type <code>op_family_t</code> are used.</dd></dl>
<p>Usage example: </p><div class="fragment"><div class="line">    <span class="keyword">struct </span><a class="code hl_class" href="classmm_1_1Gaussian.html">Dx</a> : <a class="code hl_struct" href="structmm_1_1Der1.html">Der1</a>&lt;2&gt; { <a class="code hl_class" href="classmm_1_1Gaussian.html">Dx</a>() : <a class="code hl_struct" href="structmm_1_1Der1.html">Der1</a>(0) {} };</div>
<div class="line">    <span class="keyword">struct </span>Dy : Der1&lt;2&gt; { Dy() : Der1(1) {} };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> storage = d.computeShapes&lt;std::tuple&lt;Dx, Dy, Lap&lt;2&gt;&gt;&gt;(wls);</div>
<div class="line">    <a class="code hl_function" href="classmm_1_1ExplicitVectorOperators.html#a3b786fc4844851f6257c1df8d11861b5">ExplicitVectorOperators</a>&lt;<span class="keyword">decltype</span>(storage)&gt; op(storage);</div>
<div class="line">    VectorField&lt;std::complex&lt;double&gt;, 3&gt; field(d.size());</div>
<div class="line">    std::complex&lt;double&gt; c(2.4, -0.3);</div>
<div class="line">    field.setConstant(c);</div>
<div class="line"> </div>
<div class="line">    Vec&lt;std::complex&lt;double&gt;, 3&gt; <a class="code hl_function" href="classmm_1_1ExplicitVectorOperators.html#ac35c038ad0bce86f6337c51297b864f1">lap</a> = op.apply&lt;Lap&lt;2&gt;&gt;(field, 52);</div>
<div class="line">    Vec&lt;std::complex&lt;double&gt;, 3&gt; dx = op.apply&lt;Dx&gt;(field, 34);</div>
<div class="line">    Vec&lt;std::complex&lt;double&gt;, 3&gt; dy = op.apply&lt;Dy&gt;(field, 32);</div>
<div class="ttc" id="aclassmm_1_1ExplicitVectorOperators_html_ac35c038ad0bce86f6337c51297b864f1"><div class="ttname"><a href="classmm_1_1ExplicitVectorOperators.html#ac35c038ad0bce86f6337c51297b864f1">mm::ExplicitVectorOperators::lap</a></div><div class="ttdeci">vector_type&lt; vector_field_t &gt;::type lap(const vector_field_t &amp;u, int node) const</div><div class="ttdoc">Returns Laplacian of vector field u in node with index node.</div><div class="ttdef"><b>Definition</b> <a href="ExplicitVectorOperators__fwd_8hpp_source.html#l00087">ExplicitVectorOperators_fwd.hpp:87</a></div></div>
<div class="ttc" id="astructmm_1_1Der1_html"><div class="ttname"><a href="structmm_1_1Der1.html">mm::Der1</a></div><div class="ttdoc">Represents a first derivative wrt. var.</div><div class="ttdef"><b>Definition</b> <a href="Operators__fwd_8hpp_source.html#l00141">Operators_fwd.hpp:141</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af88a56b20e9e71045c6dccc597b3a693" name="af88a56b20e9e71045c6dccc597b3a693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88a56b20e9e71045c6dccc597b3a693">&#9670;&#160;</a></span>curl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::curl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns curl of a vector field <code>u</code> in node with index <code>node</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The rotor of <code>u</code>, where <code>dim = 3</code> and \(\vec{u} = [u, v, w]\). The return value is \( \curl \vec{u} = \[\dpar{w}{y} - \dpar{v}{z}, \dpar{u}{z} - \dpar{w}{x}, \dpar{v}{x} - \dpar{u}{y}\] \) evaluated in point with index <code>node</code>, where derivatives are approximated using shape functions from <a class="el" href="classmm_1_1ExplicitVectorOperators.html#ae710a528a03642c6e49efd0b89c00e86">ss</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Static-assertion</td><td>fails if <code>u</code> is not three dimensional. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad97e967fc33fd3618d9c248fe5d661bc" name="ad97e967fc33fd3618d9c248fe5d661bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97e967fc33fd3618d9c248fe5d661bc">&#9670;&#160;</a></span>div()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type::scalar_t <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns divergence of a vector field <code>u</code> in in node with index <code>node</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The divergence of <code>u</code>, e.g. when <code>dim = 3</code> and \(\vec{u} = [u, v, w]\), the returned value is \( \nabla\cdot \vec{u} = \dpar{u}{x} + \dpar{v}{y} + \dpar{w}{z} \) evaluated in point with index <code>node</code>, where derivatives are approximated using shape functions from <a class="el" href="classmm_1_1ExplicitVectorOperators.html#ae710a528a03642c6e49efd0b89c00e86">ss</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Static-assertion</td><td>fails if the dimension of <code>u</code> is not equal to domain dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64160803e909a0f8dde8b1c0af75d28c" name="a64160803e909a0f8dde8b1c0af75d28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64160803e909a0f8dde8b1c0af75d28c">&#9670;&#160;</a></span>grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type::scalar_t, <a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type::dim, <a class="el" href="classmm_1_1ExplicitVectorOperators.html#a702f59361f77601ac71b4bec82f2a8b0a2ba4d29e16c8448be2c2a820ae287c27">dim</a> &gt; <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns gradient of vector field <code>u</code> in node with index <code>node</code>. </p>
<p>The field <code>u</code> and the domain can have different dimensions. </p><dl class="section return"><dt>Returns</dt><dd>The gradient (Jacobi matrix) of <code>u</code>, e.g. when <code><a class="el" href="classmm_1_1ExplicitVectorOperators.html#a702f59361f77601ac71b4bec82f2a8b0a2ba4d29e16c8448be2c2a820ae287c27" title="Dimensionality of the function domain.">dim(u)</a> = 3</code> and and \(\vec{u} = [u, v, w]\) and the domain dimension is 2, the returned value is  <p class="formulaDsp">
\[ \nabla \vec{u} = \begin{bmatrix}
\dpar{u}{x}, \dpar{u}{y} \\
\dpar{v}{x}, \dpar{v}{y} \\
\dpar{w}{x}, \dpar{w}{y}
\end{bmatrix} \]
</p>
 evaluated in point with index <code>node</code>, where derivatives are approximated using shape functions from <a class="el" href="classmm_1_1ExplicitVectorOperators.html#ae710a528a03642c6e49efd0b89c00e86">ss</a>. </dd></dl>

</div>
</div>
<a id="a04d104b88923f76168e394a58a6a5f66" name="a04d104b88923f76168e394a58a6a5f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d104b88923f76168e394a58a6a5f66">&#9670;&#160;</a></span>graddiv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::graddiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns gradient of divergence of a vector field <code>u</code> in in node with index <code>node</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The gradient of divergence of <code>u</code>, e.g. when <code>dim = 3</code> and \(\vec{u} = [u, v, w]\), the returned value is  <p class="formulaDsp">
\[ \nabla(\nabla\cdot \vec{u}) = \begin{bmatrix}
  \dpar{^2u}{x^2} + \dpar{^2v}{x\partial y} + \dpar{^2w}{x\partial z} \\
  \dpar{^2u}{x\partial y} + \dpar{^2v}{^2y} + \dpar{^2w}{y\partial z} \\
  \dpar{^2u}{x\partial z} + \dpar{^2v}{y\partial z} + \dpar{^2w}{^2z}
\end{bmatrix} \]
</p>
 evaluated in point with index <code>node</code>, where derivatives are approximated using shape functions from <a class="el" href="classmm_1_1ExplicitVectorOperators.html#ae710a528a03642c6e49efd0b89c00e86">ss</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Static-assertion</td><td>fails if the dimension of <code>u</code> is not equal to domain dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d951546bbba14d287f721aca7f570b4" name="a7d951546bbba14d287f721aca7f570b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d951546bbba14d287f721aca7f570b4">&#9670;&#160;</a></span>hasShapes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">bool</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::hasShapes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if operators have a non-null pointer to storage and <code>false</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html#l00072">72</a> of file <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="ac35c038ad0bce86f6337c51297b864f1" name="ac35c038ad0bce86f6337c51297b864f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35c038ad0bce86f6337c51297b864f1">&#9670;&#160;</a></span>lap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::lap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Laplacian of vector field <code>u</code> in node with index <code>node</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The Laplacian of <code>u</code>, e.g. when <code>dim = 3</code> and \(\vec{u} = [u, v, w]\), the returned value is  \( \nabla^2 \vec{u} = [
\dpar{^2 u}{x^2} + \dpar{^2 u}{y^2} + \dpar{^2 u}{z^2},
\dpar{^2 v}{x^2} + \dpar{^2 v}{y^2} + \dpar{^2 v}{z^2},
\dpar{^2 w}{x^2} + \dpar{^2 w}{y^2} + \dpar{^2 w}{z^2}
]^T\) evaluated in point with index <code>node</code> where derivatives are approximated using shape functions from <a class="el" href="classmm_1_1ExplicitVectorOperators.html#ae710a528a03642c6e49efd0b89c00e86">ss</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Static-assertion</td><td>fails if the dimension of <code>u</code> is not equal to domain dimension. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html#l00087">87</a> of file <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="afa92529f4a97a9573aeeff7032c8c40a" name="afa92529f4a97a9573aeeff7032c8c40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa92529f4a97a9573aeeff7032c8c40a">&#9670;&#160;</a></span>neumann()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::neumann </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html#a56df5a558e2406073d5f41203daa8d61">vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="structmm_1_1vector__type.html">vector_type</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">vector_field_t</a> &gt;::type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a vectorised version of <a class="el" href="classmm_1_1ExplicitOperators.html#af6db62a3f8104330369f04dda0781c29" title="Calculates a new field value a for u at node, such that the Neumann boundary condition du/dn(node) = ...">ExplicitOperators::neumann</a>. </p>
<p>Calculates a new field value <code>a</code> for <code>u</code> at <code>node</code>, such that the Neumann boundary condition <code>du/dn(node) = val</code> holds. Denote given index <code>node</code> by \(i\) and <code>val</code> by \(\vec v\). The function returns such \(\vec a\), that by setting \( \vec{u}(i) = \vec{a}\) we satisfy the condition \( \dpar{\vec u}{\vec n}(i) = \vec v\). This is done using the following formula:  </p><p class="formulaDsp">
\[ \vec{a} = \frac{ \vec{v} -
   \sum\limits_{i=1}^{s} \sum\limits_{d=1}^{dim}
     n_d \chi_{\dpar{}{ x_d}}(i)\ \vec{u}(i)
}{\sum\limits_{d=1}^{dim} n_d \chi_{\dpar{}{ x_d}}(0)},
\]
</p>
<p> where \(\chi_{\dpar{}{ x_d}}\) represents the formula for the shape function of first derivative wrt. \(d\).</p>
<dl class="section note"><dt>Note</dt><dd>A few assumptions must hold for the support domain.<ul>
<li>Each node should be its own first first support node.</li>
<li>For symmetrical supports the central node may not affect the calculated derivation and therefore this function is unable to give a value and will crash.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Scalar field to evaluate. </td></tr>
    <tr><td class="paramname">node</td><td>Index of the node, whose value should be changed to satisfy the boundary condition. </td></tr>
    <tr><td class="paramname">normal</td><td>Vector \(\vec{n}\) with the same dimensionality as the problem domain giving the direction of the derivation. Usually the unit normal vector. </td></tr>
    <tr><td class="paramname">val</td><td>The value that \(\dpar{ \vec u}{ \vec n}\) should be equal to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new value \(\vec a\), such that \(\dpar{\vec u}{\vec n} = \vec v\) after setting \(\vec u(i) = \vec a\).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Assertion</td><td>fails if <code>node</code>'s first support node is not <code>node</code>. </td></tr>
    <tr><td class="paramname">Assertion</td><td>fails if <code>node</code>'s value has negligible effect on the derivation, because no value could change the value of \(\dpar{\vec u}{\vec n}\). </td></tr>
    <tr><td class="paramname">Static-assertion</td><td>fails if the dimension of <code>u</code> is not equal to domain dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmm_1_1ExplicitOperators.html#af6db62a3f8104330369f04dda0781c29" title="Calculates a new field value a for u at node, such that the Neumann boundary condition du/dn(node) = ...">ExplicitOperators::neumann</a> </dd></dl>

</div>
</div>
<a id="ac095f65178d4b654eaa5443a010c8e8c" name="ac095f65178d4b654eaa5443a010c8e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac095f65178d4b654eaa5443a010c8e8c">&#9670;&#160;</a></span>setShapes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">void</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::setShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html#aa4ec090148a0102f47f398502aecd0f3">shape_storage_t</a> &amp;&#160;</td>
          <td class="paramname"><em>shape_storage_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a new shape storage from which this operators are generated. </p>
<p>As in the constructor, the pointer to given storage is stored as a non-owning pointer. It is the user's responsibility that given storage is valid throughout the use use of this class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape_storage_</td><td>New shape storage. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html#l00069">69</a> of file <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a5f6cf04c1f5af921a3f186003656ef73" name="a5f6cf04c1f5af921a3f186003656ef73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6cf04c1f5af921a3f186003656ef73">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">S</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classmm_1_1Gaussian.html">operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html">ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">S</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output basic info about given operators. </p>

<p class="definition">Definition at line <a class="el" href="ExplicitVectorOperators_8hpp_source.html#l00151">151</a> of file <a class="el" href="ExplicitVectorOperators_8hpp_source.html">ExplicitVectorOperators.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae710a528a03642c6e49efd0b89c00e86" name="ae710a528a03642c6e49efd0b89c00e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae710a528a03642c6e49efd0b89c00e86">&#9670;&#160;</a></span>ss</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ExplicitVectorOperators.html#aa4ec090148a0102f47f398502aecd0f3">shape_storage_t</a>* <a class="el" href="classmm_1_1ExplicitVectorOperators.html">mm::ExplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> &gt;::ss</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to shape storage, but name is shortened for readability. </p>

<p class="definition">Definition at line <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html#l00048">48</a> of file <a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/medusa/bits/operators/<a class="el" href="ExplicitVectorOperators__fwd_8hpp_source.html">ExplicitVectorOperators_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemm.html">mm</a></li><li class="navelem"><a class="el" href="classmm_1_1ExplicitVectorOperators.html">ExplicitVectorOperators</a></li>
    <li class="footer">Generated on Mon Oct 14 2024 16:54:48 for Medusa by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
