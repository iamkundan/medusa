<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medusa: mm::ImplicitVectorOperators&lt; shape_storage_type, matrix_type, rhs_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Medusa"/>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      dpar: ["\\frac{\\partial #1}{\\partial #2}", 2]
    }
  }
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://e6.ijs.si/medusa/"><img alt="Logo" src="logo_transparent.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
    <div id="projectname">Medusa
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">Coordinate Free Mehless Method implementation</div>
  </td>
   <td id="ijslogo"><a href="http://e6.ijs.si/ParallelAndDistributedSystems/"><img src="logo_ijs.png" alt="IJS_logo"></a></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.php','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmm_1_1ImplicitVectorOperators.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmm_1_1ImplicitVectorOperators-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mm::ImplicitVectorOperators&lt; shape_storage_type, matrix_type, rhs_type &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__operators.html">Operators</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a>&gt;<br />
class mm::ImplicitVectorOperators&lt; shape_storage_type, matrix_type, rhs_type &gt;</div><p>This class represents implicit vector operators that fill given matrix <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a> and right hand side <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a> with appropriate coefficients approximating differential operators with shape functions from given shape storage <a class="el" href="classmm_1_1ImplicitVectorOperators.html#acd44e9a6cc6c91978fa1eadb14071729">ss</a>. </p>
<p>They are intended for implicit solutions of vector PDEs. Component specific equations can also be set using <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a06c1cbf9baafa2821e15c27b79dd9c90">eq</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The operators <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4cdbc9c84f3bd59ad70a848f9a154ad8" title="Sets implicit equation that gradient of a vector field along v is equal to some other value.">grad()</a>, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#aa5fb8c89362488f19c74151e89d0f062" title="Sets implicit equation that value of a vector field is equal to some other value.">value()</a> etc. are lazy and will not write to the matrix until summed with another operator or assigned to. If eager evaluation is required, use the <a class="el" href="classmm_1_1ImplicitVectorOperators_1_1VecOpBase.html#a36f9c4ca8d80bca76a9e2045197c7067">eval()</a> method on each operation.</dd>
<dd>
Each evaluated operation is only <b>added</b> to the matrix and rhs. Setting the same equation twice thus has the effect of multiplying it by 2. Therefore, the matrix and the rhs should be initialized (usually to zero) before setting any equations.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">shape_storage_type</td><td>Any shape storage class satisfying the <a class="el" href="concepts.html#ss-concept">Shape storage concept</a>. </td></tr>
    <tr><td class="paramname">matrix_type</td><td>Usually and Eigen sparse matrix. </td></tr>
    <tr><td class="paramname">rhs_type</td><td>Usually an Eigen <code>VectorXd</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The matrix and rhs should be of size at least <code>N*dim</code>, where <code>N</code> is the number of nodes in the domain and <code>dim</code> its dimensionality. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmm_1_1ImplicitOperators.html" title="This class represents implicit operators that fill given matrix M and right hand side rhs with approp...">ImplicitOperators</a></dd></dl>
<p>Usage example: </p><div class="fragment"><div class="line">    Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt; <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>(2 * <a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>, 2 * <a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>);</div>
<div class="line">    <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>.reserve(<a class="code hl_class" href="classmm_1_1Gaussian.html">Range&lt;int&gt;</a>(2 * <a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>, 2 * support_size));</div>
<div class="line">    Eigen::VectorXd <a class="code hl_class" href="classmm_1_1Gaussian.html">field</a>(2 * <a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>), <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>(2 * <a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> op = <a class="code hl_class" href="classmm_1_1Gaussian.html">storage</a>.implicitVectorOperators(<a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>, <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>);</div>
<div class="line">    std::cout &lt;&lt; op &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set equation on interior</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="classmm_1_1Gaussian.html">i</a> : <a class="code hl_class" href="classmm_1_1Gaussian.html">domain</a>.interior()) {</div>
<div class="line">        <span class="keywordtype">double</span> x = <a class="code hl_class" href="classmm_1_1Gaussian.html">domain</a>.pos(<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>, 0), y = <a class="code hl_class" href="classmm_1_1Gaussian.html">domain</a>.pos(<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>, 1);</div>
<div class="line">        op.lap(<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>) + op.graddiv(<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>) = {2+4*x*y-8*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*std::sin(2*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*x), 2*(2*x*x + y*y)};</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Set boundary conditions</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -1) {</div>
<div class="line">        <span class="keywordtype">double</span> y = domain.pos(i, 1);</div>
<div class="line">        op.value(i) = {y*y, 0};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -2) {</div>
<div class="line">        <span class="keywordtype">double</span> y = domain.pos(i, 1);</div>
<div class="line">        op.value(i) = {y*y, y*y};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -3) {</div>
<div class="line">        <span class="keywordtype">double</span> x = domain.pos(i, 0);</div>
<div class="line">        op.value(i) = {std::sin(2*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*x), 0};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -4) {</div>
<div class="line">        <span class="keywordtype">double</span> x = domain.pos(i, 0);</div>
<div class="line">        op.value(i) = {1+std::sin(2*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*x), x*x};</div>
<div class="line">    }</div>
<div class="ttc" id="aclassmm_1_1Gaussian_html"><div class="ttname"><a href="classmm_1_1Gaussian.html">mm::Gaussian</a></div><div class="ttdoc">Gaussian Radial Basis Function.</div><div class="ttdef"><b>Definition</b> <a href="Gaussian__fwd_8hpp_source.html#l00029">Gaussian_fwd.hpp:29</a></div></div>
<div class="ttc" id="aclassmm_1_1ImplicitVectorOperators_html_a2d458b9fb8127458854493459927b6ad"><div class="ttname"><a href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">mm::ImplicitVectorOperators::rhs</a></div><div class="ttdeci">rhs_t * rhs</div><div class="ttdoc">Pointer to right hand side.</div><div class="ttdef"><b>Definition</b> <a href="ImplicitVectorOperators__fwd_8hpp_source.html#l00063">ImplicitVectorOperators_fwd.hpp:63</a></div></div>
<div class="ttc" id="aclassmm_1_1ImplicitVectorOperators_html_ae9519c74815de424a5d88b097b677f87"><div class="ttname"><a href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">mm::ImplicitVectorOperators::M</a></div><div class="ttdeci">matrix_t * M</div><div class="ttdoc">Pointer to problem matrix.</div><div class="ttdef"><b>Definition</b> <a href="ImplicitVectorOperators__fwd_8hpp_source.html#l00062">ImplicitVectorOperators_fwd.hpp:62</a></div></div>
<div class="ttc" id="anamespacemm_html_add5120ca222cb67674865bb4ea92cfae"><div class="ttname"><a href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">mm::PI</a></div><div class="ttdeci">static const double PI</div><div class="ttdoc">Mathematical constant pi in double precision.</div><div class="ttdef"><b>Definition</b> <a href="Config_8hpp_source.html#l00044">Config.hpp:44</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00044">44</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff7eaa070dbe22bbe6759d0c65a47a01" id="r_aff7eaa070dbe22bbe6759d0c65a47a01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#aff7eaa070dbe22bbe6759d0c65a47a01">ImplicitVectorOperators</a> ()</td></tr>
<tr class="memdesc:aff7eaa070dbe22bbe6759d0c65a47a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor sets offset to <code>0</code> and pointers to <code>nullptr</code>.  <br /></td></tr>
<tr class="separator:aff7eaa070dbe22bbe6759d0c65a47a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fec89227a553d8c8f92cfccbae8872" id="r_a80fec89227a553d8c8f92cfccbae8872"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a80fec89227a553d8c8f92cfccbae8872">ImplicitVectorOperators</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a58618cbb858929ea0248bf61d52bbd98">shape_storage_t</a> &amp;<a class="el" href="classmm_1_1ImplicitVectorOperators.html#acd44e9a6cc6c91978fa1eadb14071729">ss</a>)</td></tr>
<tr class="memdesc:a80fec89227a553d8c8f92cfccbae8872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set only shape storage, the rest as default constructor.  <br /></td></tr>
<tr class="separator:a80fec89227a553d8c8f92cfccbae8872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176234bb07419ccb5976336b3324ca98" id="r_a176234bb07419ccb5976336b3324ca98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a176234bb07419ccb5976336b3324ca98">ImplicitVectorOperators</a> (<a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a58618cbb858929ea0248bf61d52bbd98">shape_storage_t</a> &amp;<a class="el" href="classmm_1_1ImplicitVectorOperators.html#acd44e9a6cc6c91978fa1eadb14071729">ss</a>, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2404465cccd97faba3cbd969ec3ded24">matrix_t</a> &amp;<a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a305217f7605dae34ae19a1c0ba48e6f1">rhs_t</a> &amp;<a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae7bb6d892277faabf4841119ab416a76">row_offset</a>=0, <a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a143aade67b6261190c42ab7857290c81">col_offset</a>=0)</td></tr>
<tr class="memdesc:a176234bb07419ccb5976336b3324ca98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set shape storage and problem matrix and rhs.  <br /></td></tr>
<tr class="separator:a176234bb07419ccb5976336b3324ca98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa905c9aca385362d817892645df02662" id="r_aa905c9aca385362d817892645df02662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#aa905c9aca385362d817892645df02662">setProblem</a> (<a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2404465cccd97faba3cbd969ec3ded24">matrix_t</a> &amp;<a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a305217f7605dae34ae19a1c0ba48e6f1">rhs_t</a> &amp;<a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae7bb6d892277faabf4841119ab416a76">row_offset</a>=0, <a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a143aade67b6261190c42ab7857290c81">col_offset</a>=0)</td></tr>
<tr class="memdesc:aa905c9aca385362d817892645df02662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets current matrix and right hand side.  <br /></td></tr>
<tr class="separator:aa905c9aca385362d817892645df02662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982f91b629f8ede36242eafff90af2e8" id="r_a982f91b629f8ede36242eafff90af2e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a982f91b629f8ede36242eafff90af2e8">setRowOffset</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae7bb6d892277faabf4841119ab416a76">row_offset</a>)</td></tr>
<tr class="memdesc:a982f91b629f8ede36242eafff90af2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets row offset for given matrix, treating it as is the first row had index <code>row_offset</code>.  <br /></td></tr>
<tr class="separator:a982f91b629f8ede36242eafff90af2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6244d56fb91a7764fa910be0dae478" id="r_a5f6244d56fb91a7764fa910be0dae478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a5f6244d56fb91a7764fa910be0dae478">setColOffset</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a143aade67b6261190c42ab7857290c81">col_offset</a>)</td></tr>
<tr class="memdesc:a5f6244d56fb91a7764fa910be0dae478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets col offset for given matrix, treating it as is the first column had index <code>col_offset</code>.  <br /></td></tr>
<tr class="separator:a5f6244d56fb91a7764fa910be0dae478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd7371d3d5b981ad081f80a7d614a62" id="r_a6fd7371d3d5b981ad081f80a7d614a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a6fd7371d3d5b981ad081f80a7d614a62">hasShapes</a> () <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:a6fd7371d3d5b981ad081f80a7d614a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if operators have a non-null pointer to storage and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:a6fd7371d3d5b981ad081f80a7d614a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec7d8dc8bed3fe6674bbdb49a647be3" id="r_aaec7d8dc8bed3fe6674bbdb49a647be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#aaec7d8dc8bed3fe6674bbdb49a647be3">hasMatrix</a> () <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:aaec7d8dc8bed3fe6674bbdb49a647be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if operators have a non-null pointer to problem matrix.  <br /></td></tr>
<tr class="separator:aaec7d8dc8bed3fe6674bbdb49a647be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d2cfc7432e4446a58d2301a81cb705" id="r_a90d2cfc7432e4446a58d2301a81cb705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a90d2cfc7432e4446a58d2301a81cb705">hasRhs</a> () <a class="el" href="classmm_1_1Gaussian.html">const</a></td></tr>
<tr class="memdesc:a90d2cfc7432e4446a58d2301a81cb705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if operators have a non-null pointer to problem right hand side.  <br /></td></tr>
<tr class="separator:a90d2cfc7432e4446a58d2301a81cb705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c1cbf9baafa2821e15c27b79dd9c90" id="r_a06c1cbf9baafa2821e15c27b79dd9c90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1Equation.html">Equation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a06c1cbf9baafa2821e15c27b79dd9c90">eq</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1Gaussian.html">num</a>)</td></tr>
<tr class="memdesc:a06c1cbf9baafa2821e15c27b79dd9c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose one specific component of the vector equation to write to.  <br /></td></tr>
<tr class="separator:a06c1cbf9baafa2821e15c27b79dd9c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fb8c89362488f19c74151e89d0f062" id="r_aa5fb8c89362488f19c74151e89d0f062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1ValueOp.html">ValueOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#aa5fb8c89362488f19c74151e89d0f062">value</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">int</a> row)</td></tr>
<tr class="memdesc:aa5fb8c89362488f19c74151e89d0f062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets implicit equation that value of a vector field is equal to some other value.  <br /></td></tr>
<tr class="separator:aa5fb8c89362488f19c74151e89d0f062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0682dcb439ee9d5bef2396f2fd450b36" id="r_a0682dcb439ee9d5bef2396f2fd450b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1ValueOp.html">ValueOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0682dcb439ee9d5bef2396f2fd450b36">value</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node)</td></tr>
<tr class="memdesc:a0682dcb439ee9d5bef2396f2fd450b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#aa5fb8c89362488f19c74151e89d0f062">value</a> with row equal to current node.  <br /></td></tr>
<tr class="separator:a0682dcb439ee9d5bef2396f2fd450b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a5ce2f46b81ed0512efd638720607c" id="r_a66a5ce2f46b81ed0512efd638720607c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a>&lt; <a class="el" href="structmm_1_1Lap.html">Lap</a>&lt; <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a1b564fe24def4e4a7ffb72013b7ad80ca7ce70b5be9ed05376062f8e4f2b32a85">dim</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a66a5ce2f46b81ed0512efd638720607c">lap</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">int</a> row)</td></tr>
<tr class="memdesc:a66a5ce2f46b81ed0512efd638720607c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets implicit equation that Laplacian of a vector field is equal to some other value.  <br /></td></tr>
<tr class="separator:a66a5ce2f46b81ed0512efd638720607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db926808f3261b109dd638e91a318a0" id="r_a4db926808f3261b109dd638e91a318a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a>&lt; <a class="el" href="structmm_1_1Lap.html">Lap</a>&lt; <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a1b564fe24def4e4a7ffb72013b7ad80ca7ce70b5be9ed05376062f8e4f2b32a85">dim</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4db926808f3261b109dd638e91a318a0">lap</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node)</td></tr>
<tr class="memdesc:a4db926808f3261b109dd638e91a318a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a66a5ce2f46b81ed0512efd638720607c">lap</a> with row equal to current node.  <br /></td></tr>
<tr class="separator:a4db926808f3261b109dd638e91a318a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aee2a76c9c66890e3c6e404e392839f" id="r_a4aee2a76c9c66890e3c6e404e392839f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt; </td></tr>
<tr class="memitem:a4aee2a76c9c66890e3c6e404e392839f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4aee2a76c9c66890e3c6e404e392839f">apply</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">typename</a> op_family_t::operator_t o, <a class="el" href="classmm_1_1Gaussian.html">int</a> row)</td></tr>
<tr class="memdesc:a4aee2a76c9c66890e3c6e404e392839f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the weights for operator <code>o</code> to the appropriate elements in the matrix.  <br /></td></tr>
<tr class="separator:a4aee2a76c9c66890e3c6e404e392839f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad712abcd7cb915ba9e9936e2c3cf348e" id="r_ad712abcd7cb915ba9e9936e2c3cf348e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt; </td></tr>
<tr class="memitem:ad712abcd7cb915ba9e9936e2c3cf348e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ad712abcd7cb915ba9e9936e2c3cf348e">apply</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">typename</a> op_family_t::operator_t o)</td></tr>
<tr class="memdesc:ad712abcd7cb915ba9e9936e2c3cf348e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4aee2a76c9c66890e3c6e404e392839f">apply</a> with row equal to current node.  <br /></td></tr>
<tr class="separator:ad712abcd7cb915ba9e9936e2c3cf348e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2ec37919321cef86cf8a9004ea400e" id="r_a4e2ec37919321cef86cf8a9004ea400e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt; </td></tr>
<tr class="memitem:a4e2ec37919321cef86cf8a9004ea400e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4e2ec37919321cef86cf8a9004ea400e">apply</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node)</td></tr>
<tr class="memdesc:a4e2ec37919321cef86cf8a9004ea400e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for default-constructible operator.  <br /></td></tr>
<tr class="separator:a4e2ec37919321cef86cf8a9004ea400e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdbc9c84f3bd59ad70a848f9a154ad8" id="r_a4cdbc9c84f3bd59ad70a848f9a154ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradOp.html">GradOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4cdbc9c84f3bd59ad70a848f9a154ad8">grad</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;v, <a class="el" href="classmm_1_1Gaussian.html">int</a> row)</td></tr>
<tr class="memdesc:a4cdbc9c84f3bd59ad70a848f9a154ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets implicit equation that gradient of a vector field along <code>v</code> is equal to some other value.  <br /></td></tr>
<tr class="separator:a4cdbc9c84f3bd59ad70a848f9a154ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae413739b68208365a8d92d65054c5012" id="r_ae413739b68208365a8d92d65054c5012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradOp.html">GradOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae413739b68208365a8d92d65054c5012">grad</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;v)</td></tr>
<tr class="memdesc:ae413739b68208365a8d92d65054c5012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4cdbc9c84f3bd59ad70a848f9a154ad8">grad</a> with row equal to current node.  <br /></td></tr>
<tr class="separator:ae413739b68208365a8d92d65054c5012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad437ada41a213bed7bbd8799a889dc9f" id="r_ad437ada41a213bed7bbd8799a889dc9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradDivOp.html">GradDivOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ad437ada41a213bed7bbd8799a889dc9f">graddiv</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">int</a> row)</td></tr>
<tr class="memdesc:ad437ada41a213bed7bbd8799a889dc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets implicit equation that gradient of divergence of a vector field is equal to some other value.  <br /></td></tr>
<tr class="separator:ad437ada41a213bed7bbd8799a889dc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c0c65935c24c516113009c7cd344be" id="r_af3c0c65935c24c516113009c7cd344be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradDivOp.html">GradDivOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#af3c0c65935c24c516113009c7cd344be">graddiv</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node)</td></tr>
<tr class="memdesc:af3c0c65935c24c516113009c7cd344be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ad437ada41a213bed7bbd8799a889dc9f">graddiv</a> with row equal to current node.  <br /></td></tr>
<tr class="separator:af3c0c65935c24c516113009c7cd344be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6dfabbc7847f1ca0230c0baaf89e6f" id="r_afa6dfabbc7847f1ca0230c0baaf89e6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradOp.html">GradOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#afa6dfabbc7847f1ca0230c0baaf89e6f">neumann</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">unit_normal</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> row)</td></tr>
<tr class="memdesc:afa6dfabbc7847f1ca0230c0baaf89e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets neumann boundary conditions in node <code>node</code>.  <br /></td></tr>
<tr class="separator:afa6dfabbc7847f1ca0230c0baaf89e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d480d361d6e245fc76ecaf1f954a473" id="r_a6d480d361d6e245fc76ecaf1f954a473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradOp.html">GradOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a6d480d361d6e245fc76ecaf1f954a473">neumann</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">n</a>)</td></tr>
<tr class="memdesc:a6d480d361d6e245fc76ecaf1f954a473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#afa6dfabbc7847f1ca0230c0baaf89e6f">neumann</a> with row equal to current node.  <br /></td></tr>
<tr class="separator:a6d480d361d6e245fc76ecaf1f954a473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c2a73830aa60865f6f4fb0a8220345" id="r_ac9c2a73830aa60865f6f4fb0a8220345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1TractionOp.html">TractionOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ac9c2a73830aa60865f6f4fb0a8220345">traction</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a> lam, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a> mu, <a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">unit_normal</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> row)</td></tr>
<tr class="memdesc:ac9c2a73830aa60865f6f4fb0a8220345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets traction boundary conditions in node <code>node</code>.  <br /></td></tr>
<tr class="separator:ac9c2a73830aa60865f6f4fb0a8220345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25a0b1d0704d6e81ed3ab1a3e6e01cf" id="r_ad25a0b1d0704d6e81ed3ab1a3e6e01cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1TractionOp.html">TractionOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ad25a0b1d0704d6e81ed3ab1a3e6e01cf">traction</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> node, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a> lam, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a> mu, <a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;<a class="el" href="classmm_1_1Gaussian.html">n</a>)</td></tr>
<tr class="memdesc:ad25a0b1d0704d6e81ed3ab1a3e6e01cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ac9c2a73830aa60865f6f4fb0a8220345">traction</a> with row equal to current node.  <br /></td></tr>
<tr class="separator:ad25a0b1d0704d6e81ed3ab1a3e6e01cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1b564fe24def4e4a7ffb72013b7ad80c" id="r_a1b564fe24def4e4a7ffb72013b7ad80c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a1b564fe24def4e4a7ffb72013b7ad80ca7ce70b5be9ed05376062f8e4f2b32a85">dim</a> = shape_storage_t::dim
 }</td></tr>
<tr class="memdesc:a1b564fe24def4e4a7ffb72013b7ad80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store dimension of the domain.  <a href="classmm_1_1ImplicitVectorOperators.html#a1b564fe24def4e4a7ffb72013b7ad80c">More...</a><br /></td></tr>
<tr class="separator:a1b564fe24def4e4a7ffb72013b7ad80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58618cbb858929ea0248bf61d52bbd98" id="r_a58618cbb858929ea0248bf61d52bbd98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">typedef</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a58618cbb858929ea0248bf61d52bbd98">shape_storage_t</a></td></tr>
<tr class="memdesc:a58618cbb858929ea0248bf61d52bbd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of shape storage.  <br /></td></tr>
<tr class="separator:a58618cbb858929ea0248bf61d52bbd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2404465cccd97faba3cbd969ec3ded24" id="r_a2404465cccd97faba3cbd969ec3ded24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">typedef</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2404465cccd97faba3cbd969ec3ded24">matrix_t</a></td></tr>
<tr class="memdesc:a2404465cccd97faba3cbd969ec3ded24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type.  <br /></td></tr>
<tr class="separator:a2404465cccd97faba3cbd969ec3ded24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305217f7605dae34ae19a1c0ba48e6f1" id="r_a305217f7605dae34ae19a1c0ba48e6f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">typedef</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a305217f7605dae34ae19a1c0ba48e6f1">rhs_t</a></td></tr>
<tr class="memdesc:a305217f7605dae34ae19a1c0ba48e6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right hand side type.  <br /></td></tr>
<tr class="separator:a305217f7605dae34ae19a1c0ba48e6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47859ef66ea0612c1b2a3e421b01288" id="r_ab47859ef66ea0612c1b2a3e421b01288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">typedef</a> shape_storage_t::vector_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a></td></tr>
<tr class="memdesc:ab47859ef66ea0612c1b2a3e421b01288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type for vectors in the domain, usually float or double.  <br /></td></tr>
<tr class="separator:ab47859ef66ea0612c1b2a3e421b01288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7736515f1b8c962dbdb49ad3e54fb7" id="r_a0b7736515f1b8c962dbdb49ad3e54fb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">typedef</a> <a class="el" href="classmm_1_1Gaussian.html#a09cd0a9192470c8b9444ddd17b32a7a0">matrix_t::Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a></td></tr>
<tr class="memdesc:a0b7736515f1b8c962dbdb49ad3e54fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type of matrix elements.  <br /></td></tr>
<tr class="separator:a0b7736515f1b8c962dbdb49ad3e54fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27601e8e8f58ca84727b249bbfd18e6a" id="r_a27601e8e8f58ca84727b249bbfd18e6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">typedef</a> Eigen::Matrix&lt; <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a>, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a1b564fe24def4e4a7ffb72013b7ad80ca7ce70b5be9ed05376062f8e4f2b32a85">dim</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a27601e8e8f58ca84727b249bbfd18e6a">vector_t</a></td></tr>
<tr class="memdesc:a27601e8e8f58ca84727b249bbfd18e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type.  <br /></td></tr>
<tr class="separator:a27601e8e8f58ca84727b249bbfd18e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing basic operators.  <a href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1Equation.html">Equation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents one scalar component of a vector equation.  <a href="classmm_1_1ImplicitVectorOperators_1_1Equation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradDivOp.html">GradDivOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the gradient of the divergence operator, i.e. operator \(\nabla\nabla\cdot\).  <a href="classmm_1_1ImplicitVectorOperators_1_1GradDivOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradOp.html">GradOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the directional derivative (gradient) operation.  <a href="classmm_1_1ImplicitVectorOperators_1_1GradOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1RowVecOp.html">RowVecOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an operation on a specific set of rows of the matrix.  <a href="classmm_1_1ImplicitVectorOperators_1_1RowVecOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1TractionOp.html">TractionOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the traction operator. Useful for setting boundary conditions.  <a href="classmm_1_1ImplicitVectorOperators_1_1TractionOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1ValueOp.html">ValueOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the "evaluate" operation, i.e. the zero-th derivative.  <a href="classmm_1_1ImplicitVectorOperators_1_1ValueOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1VecOpBase.html">VecOpBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all elementary implicit vector operations.  <a href="classmm_1_1ImplicitVectorOperators_1_1VecOpBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a51a52afff676957599c7a6db586e113d" id="r_a51a52afff676957599c7a6db586e113d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">S</a> , <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a> , <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">R</a> &gt; </td></tr>
<tr class="memitem:a51a52afff676957599c7a6db586e113d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a51a52afff676957599c7a6db586e113d">operator&lt;&lt;</a> (std::ostream &amp;<a class="el" href="classmm_1_1Gaussian.html">os</a>, <a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">S</a>, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>, <a class="el" href="classmm_1_1Gaussian.html">R</a> &gt; &amp;op)</td></tr>
<tr class="memdesc:a51a52afff676957599c7a6db586e113d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output basic info about given operators.  <br /></td></tr>
<tr class="separator:a51a52afff676957599c7a6db586e113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a795deb42aa1c7c1d06b453d031a9a43f" id="r_a795deb42aa1c7c1d06b453d031a9a43f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a795deb42aa1c7c1d06b453d031a9a43f">addToM</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1Gaussian.html">i</a>, <a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1Gaussian.html">j</a>, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a> v)</td></tr>
<tr class="memdesc:a795deb42aa1c7c1d06b453d031a9a43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>v</code> to <code><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87" title="Pointer to problem matrix.">M(i, j)</a></code>, i.e. <code><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87" title="Pointer to problem matrix.">M(i, j)</a> += v</code>.  <br /></td></tr>
<tr class="separator:a795deb42aa1c7c1d06b453d031a9a43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62fbce3fa9ce567082eed7f8a147a53" id="r_af62fbce3fa9ce567082eed7f8a147a53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#af62fbce3fa9ce567082eed7f8a147a53">addToRhs</a> (<a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1Gaussian.html">i</a>, <a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a27601e8e8f58ca84727b249bbfd18e6a">vector_t</a> &amp;v)</td></tr>
<tr class="memdesc:af62fbce3fa9ce567082eed7f8a147a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds components of <code>v</code> to <code>i</code>, <code>i+N</code>, ..., <code>i+(dim-1)*N</code>-th rows of <code>rhs</code>.  <br /></td></tr>
<tr class="separator:af62fbce3fa9ce567082eed7f8a147a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acd44e9a6cc6c91978fa1eadb14071729" id="r_acd44e9a6cc6c91978fa1eadb14071729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a58618cbb858929ea0248bf61d52bbd98">shape_storage_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#acd44e9a6cc6c91978fa1eadb14071729">ss</a></td></tr>
<tr class="memdesc:acd44e9a6cc6c91978fa1eadb14071729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape storage, but name is shortened for readability.  <br /></td></tr>
<tr class="separator:acd44e9a6cc6c91978fa1eadb14071729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9519c74815de424a5d88b097b677f87" id="r_ae9519c74815de424a5d88b097b677f87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2404465cccd97faba3cbd969ec3ded24">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a></td></tr>
<tr class="memdesc:ae9519c74815de424a5d88b097b677f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to problem matrix.  <br /></td></tr>
<tr class="separator:ae9519c74815de424a5d88b097b677f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d458b9fb8127458854493459927b6ad" id="r_a2d458b9fb8127458854493459927b6ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a305217f7605dae34ae19a1c0ba48e6f1">rhs_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a></td></tr>
<tr class="memdesc:a2d458b9fb8127458854493459927b6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to right hand side.  <br /></td></tr>
<tr class="separator:a2d458b9fb8127458854493459927b6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bb6d892277faabf4841119ab416a76" id="r_ae7bb6d892277faabf4841119ab416a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae7bb6d892277faabf4841119ab416a76">row_offset</a></td></tr>
<tr class="memdesc:ae7bb6d892277faabf4841119ab416a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row offset to be used when accessing matrix or rhs coefficients.  <br /></td></tr>
<tr class="separator:ae7bb6d892277faabf4841119ab416a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143aade67b6261190c42ab7857290c81" id="r_a143aade67b6261190c42ab7857290c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a143aade67b6261190c42ab7857290c81">col_offset</a></td></tr>
<tr class="memdesc:a143aade67b6261190c42ab7857290c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column offset to be used when accessing matrix coefficients.  <br /></td></tr>
<tr class="separator:a143aade67b6261190c42ab7857290c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a1b564fe24def4e4a7ffb72013b7ad80c" name="a1b564fe24def4e4a7ffb72013b7ad80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b564fe24def4e4a7ffb72013b7ad80c">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">anonymous</a> <a class="el" href="classmm_1_1Gaussian.html">enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store dimension of the domain. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1b564fe24def4e4a7ffb72013b7ad80ca7ce70b5be9ed05376062f8e4f2b32a85" name="a1b564fe24def4e4a7ffb72013b7ad80ca7ce70b5be9ed05376062f8e4f2b32a85"></a>dim&#160;</td><td class="fielddoc"><p>Dimensionality of the domain. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00055">55</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aff7eaa070dbe22bbe6759d0c65a47a01" name="aff7eaa070dbe22bbe6759d0c65a47a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7eaa070dbe22bbe6759d0c65a47a01">&#9670;&#160;</a></span>ImplicitVectorOperators() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::ImplicitVectorOperators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor sets offset to <code>0</code> and pointers to <code>nullptr</code>. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00319">319</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a80fec89227a553d8c8f92cfccbae8872" name="a80fec89227a553d8c8f92cfccbae8872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fec89227a553d8c8f92cfccbae8872">&#9670;&#160;</a></span>ImplicitVectorOperators() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::ImplicitVectorOperators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a58618cbb858929ea0248bf61d52bbd98">shape_storage_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set only shape storage, the rest as default constructor. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00322">322</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a176234bb07419ccb5976336b3324ca98" name="a176234bb07419ccb5976336b3324ca98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176234bb07419ccb5976336b3324ca98">&#9670;&#160;</a></span>ImplicitVectorOperators() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::ImplicitVectorOperators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a58618cbb858929ea0248bf61d52bbd98">shape_storage_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2404465cccd97faba3cbd969ec3ded24">matrix_t</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a305217f7605dae34ae19a1c0ba48e6f1">rhs_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>row_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>col_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set shape storage and problem matrix and rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>Class storing all computed shapes. </td></tr>
    <tr><td class="paramname">M</td><td>Problem matrix. Must have at least <code>ss-&gt;size()*<a class="el" href="classmm_1_1ImplicitVectorOperators.html#a1b564fe24def4e4a7ffb72013b7ad80ca7ce70b5be9ed05376062f8e4f2b32a85" title="Dimensionality of the domain.">dim</a></code> rows and cols. </td></tr>
    <tr><td class="paramname">rhs</td><td>Problem right hand side. Must have at least <code>ss-&gt;size()*<a class="el" href="classmm_1_1ImplicitVectorOperators.html#a1b564fe24def4e4a7ffb72013b7ad80ca7ce70b5be9ed05376062f8e4f2b32a85" title="Dimensionality of the domain.">dim</a></code> rows. </td></tr>
    <tr><td class="paramname">row_offset</td><td>Instead of counting rows from 0, count them from row <code>row_offset</code>. </td></tr>
    <tr><td class="paramname">col_offset</td><td>Instead of counting columns from 0, count them from row <code>col_offset</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Matrices <code>M</code> and <code>rhs</code> have values only added to them and should be zero initialized by the user. Since this is a common mistake, a warning is printed if this is not the case when in debug mode.</dd></dl>
<p>This class is usually constructed directly from shape storage using the <code>implicitVectorOperators()</code> member function. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators_8hpp_source.html#l00016">16</a> of file <a class="el" href="ImplicitVectorOperators_8hpp_source.html">ImplicitVectorOperators.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a795deb42aa1c7c1d06b453d031a9a43f" name="a795deb42aa1c7c1d06b453d031a9a43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795deb42aa1c7c1d06b453d031a9a43f">&#9670;&#160;</a></span>addToM()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">void</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::addToM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <code>v</code> to <code><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87" title="Pointer to problem matrix.">M(i, j)</a></code>, i.e. <code><a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87" title="Pointer to problem matrix.">M(i, j)</a> += v</code>. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00068">68</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="af62fbce3fa9ce567082eed7f8a147a53" name="af62fbce3fa9ce567082eed7f8a147a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62fbce3fa9ce567082eed7f8a147a53">&#9670;&#160;</a></span>addToRhs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">void</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::addToRhs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a27601e8e8f58ca84727b249bbfd18e6a">vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds components of <code>v</code> to <code>i</code>, <code>i+N</code>, ..., <code>i+(dim-1)*N</code>-th rows of <code>rhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00074">74</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a4e2ec37919321cef86cf8a9004ea400e" name="a4e2ec37919321cef86cf8a9004ea400e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2ec37919321cef86cf8a9004ea400e">&#9670;&#160;</a></span>apply() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt; <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for default-constructible operator. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00445">445</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="ad712abcd7cb915ba9e9936e2c3cf348e" name="ad712abcd7cb915ba9e9936e2c3cf348e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad712abcd7cb915ba9e9936e2c3cf348e">&#9670;&#160;</a></span>apply() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt; <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">typename</a> op_family_t::operator_t&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4aee2a76c9c66890e3c6e404e392839f">apply</a> with row equal to current node. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00439">439</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a4aee2a76c9c66890e3c6e404e392839f" name="a4aee2a76c9c66890e3c6e404e392839f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aee2a76c9c66890e3c6e404e392839f">&#9670;&#160;</a></span>apply() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">op_family_t</a> &gt; <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">typename</a> op_family_t::operator_t&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the weights for operator <code>o</code> to the appropriate elements in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">o</td><td><a class="el" href="structmm_1_1Operator.html" title="Base class for a differential operator.">Operator</a> family </td></tr>
    <tr><td class="paramname">row</td><td>Write in this matrix row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function is lazy and returns an "operation" which will write the weights in the matrix, when evaluated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00433">433</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a06c1cbf9baafa2821e15c27b79dd9c90" name="a06c1cbf9baafa2821e15c27b79dd9c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c1cbf9baafa2821e15c27b79dd9c90">&#9670;&#160;</a></span>eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1Equation.html">Equation</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Choose one specific component of the vector equation to write to. </p>
<p>Usage example: </p><div class="fragment"><div class="line">        <a class="code hl_class" href="classmm_1_1Gaussian.html">alpha</a>*op.eq(0).c(0).der1(<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>, 0) + <a class="code hl_class" href="classmm_1_1Gaussian.html">beta</a>*op.eq(0).c(1).der1(<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>, 1) = <a class="code hl_class" href="classmm_1_1Gaussian.html">tx</a>(<a class="code hl_class" href="classmm_1_1Gaussian.html">domain</a>.pos(<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>));</div>
</div><!-- fragment --><p> sets equation \(\alpha \dpar{u}{x}(i) + \beta \dpar{v}{y}(i) = t_x(i)\) as the first scalar equation in the matrix. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1Equation.html#ac0580221e17e101d3ca52f908c685a4e" title="Returns ordinary ImplicitOperators for component comp of equation eq_idx.">Equation::c</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00374">374</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="ae413739b68208365a8d92d65054c5012" name="ae413739b68208365a8d92d65054c5012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae413739b68208365a8d92d65054c5012">&#9670;&#160;</a></span>grad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradOp.html">GradOp</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4cdbc9c84f3bd59ad70a848f9a154ad8">grad</a> with row equal to current node. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00467">467</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a4cdbc9c84f3bd59ad70a848f9a154ad8" name="a4cdbc9c84f3bd59ad70a848f9a154ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdbc9c84f3bd59ad70a848f9a154ad8">&#9670;&#160;</a></span>grad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradOp.html">GradOp</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets implicit equation that gradient of a vector field along <code>v</code> is equal to some other value. </p>
<p>The code <code>alpha*op.grad(node, v) = r</code> fills the <code>node</code>-th, <code>node+N</code>-th and <code>node+2*N</code>-th row of matrix <code>M</code> these rows of equation \( M u = r \) are a good approximation of the equation </p><p class="formulaDsp">
\[ \alpha (\vec{v} \cdot \nabla) \vec{u}(p) = \vec{r}(p), \]
</p>
<p> where \(p\) is the <code>node</code>-th point and \(\vec{v}\) is the vector <code>v</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Above example was made for <code>dim = 3</code>, other dimensions are analogous. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Index of a node from 0 to <code>N</code> for which to write the equation for. This means only <code>node</code>-th<code>, node+N</code>-th and <code>node+2*N</code>-th rows of the matrix are changed. User must make sure that the matrix is large enough. </td></tr>
    <tr><td class="paramname">row</td><td>Write equation in this specific row. Row with index <code>node</code> is chosen by default. </td></tr>
    <tr><td class="paramname">v</td><td>Vector to multiply the gradient with.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">    <span class="comment">// Solve problem for u unknown vector field:</span></div>
<div class="line">    <span class="comment">// grad u . v + 1/2 laplace u = f</span></div>
<div class="line">    <span class="comment">// grad u . (y, x) + 1/2 laplace u = (x^3+y+2 x y^2, x^2+(y-1) y)</span></div>
<div class="line">    <span class="comment">// on [0, 1] x [0, 1] with BC:</span></div>
<div class="line">    <span class="comment">// u(x, 0) = (0, -x)</span></div>
<div class="line">    <span class="comment">// u(x, 1) = (x*x, 0)</span></div>
<div class="line">    <span class="comment">// u(0, y) = (0, 0)</span></div>
<div class="line">    <span class="comment">// u(1, y) = (y, y-1)</span></div>
<div class="line">    <span class="comment">// with solution:</span></div>
<div class="line">    <span class="comment">// u(x, y) = (x^2 y, yx - x)</span></div>
<div class="line">    std::function&lt;<a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a>(<a class="code hl_class" href="classmm_1_1Gaussian.html">Vec2d</a>)&gt; <a class="code hl_class" href="classmm_1_1Gaussian.html">analytical</a> = [] (<span class="keyword">const</span> <a class="code hl_class" href="classmm_1_1Gaussian.html">Vec2d</a>&amp; p) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a>(p[0]*p[0]*p[1], (p[1]-1)*p[0]);</div>
<div class="line">    };</div>
<div class="line">    <span class="comment">// Prepare domain</span></div>
<div class="line">    <a class="code hl_class" href="classmm_1_1Gaussian.html">BoxShape&lt;Vec2d&gt;</a> <a class="code hl_class" href="classmm_1_1Gaussian.html">box</a>(0., 1.);</div>
<div class="line">    <a class="code hl_class" href="classmm_1_1Gaussian.html">DomainDiscretization&lt;Vec2d&gt;</a> <a class="code hl_class" href="classmm_1_1Gaussian.html">domain</a> = <a class="code hl_class" href="classmm_1_1Gaussian.html">box</a>.discretizeWithStep(0.05);</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_class" href="classmm_1_1Gaussian.html">N</a> = <a class="code hl_class" href="classmm_1_1Gaussian.html">domain</a>.size();</div>
<div class="line">    <span class="keywordtype">int</span> support_size = 9;</div>
<div class="line">    <a class="code hl_class" href="classmm_1_1Gaussian.html">domain</a>.findSupport(<a class="code hl_class" href="classmm_1_1FindClosest.html">FindClosest</a>(support_size));</div>
<div class="line">    <span class="comment">// Prepare operators and matrix</span></div>
<div class="line">    <a class="code hl_class" href="classmm_1_1Gaussian.html">WLS&lt;Monomials&lt;Vec2d&gt;</a>, <a class="code hl_class" href="classmm_1_1Gaussian.html">GaussianWeight&lt;Vec2d&gt;</a>&gt; <a class="code hl_class" href="classmm_1_1Gaussian.html">wls</a>(2, 15.0 / <a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>);</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_class" href="classmm_1_1Gaussian.html">storage</a> = <a class="code hl_class" href="classmm_1_1Gaussian.html">domain</a>.computeShapes(<a class="code hl_class" href="classmm_1_1Gaussian.html">wls</a>);</div>
<div class="line">    Eigen::SparseMatrix&lt;double&gt; <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>(2*<a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>, 2*<a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>);</div>
<div class="line">    <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>.reserve(<a class="code hl_class" href="classmm_1_1Gaussian.html">storage</a>.supportSizes()+<a class="code hl_class" href="classmm_1_1Gaussian.html">storage</a>.supportSizes());</div>
<div class="line">    Eigen::VectorXd <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>(2*<a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>); <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>.setZero();</div>
<div class="line">    <span class="keyword">auto</span> op = <a class="code hl_class" href="classmm_1_1Gaussian.html">storage</a>.implicitVectorOperators(<a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>, <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmm_1_1Gaussian.html">Range&lt;Vec2d&gt;</a> v(<a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code hl_class" href="classmm_1_1Gaussian.html">i</a> = 0; <a class="code hl_class" href="classmm_1_1Gaussian.html">i</a> &lt; <a class="code hl_class" href="classmm_1_1Gaussian.html">N</a>; ++<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>) {</div>
<div class="line">        v[<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>] = <a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a>({<a class="code hl_class" href="classmm_1_1Gaussian.html">domain</a>.pos(<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>, 1), <a class="code hl_class" href="classmm_1_1Gaussian.html">domain</a>.pos(<a class="code hl_class" href="classmm_1_1Gaussian.html">i</a>, 0)});</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Set equation on interior</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.interior()) {</div>
<div class="line">        <span class="keywordtype">double</span> x = domain.pos(i, 0), y = domain.pos(i, 1);</div>
<div class="line">        op.grad(i, v[i]) + 0.5*op.lap(i) = {x*x*x + y + 2*x*y*y, x*x + (y-1)*y};</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Set boundary conditions</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -1) {</div>
<div class="line">        op.value(i) = 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -2) {</div>
<div class="line">        <span class="keywordtype">double</span> y = domain.pos(i, 1);</div>
<div class="line">        op.value(i) = {y, y-1};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -3) {</div>
<div class="line">        <span class="keywordtype">double</span> x = domain.pos(i, 0);</div>
<div class="line">        op.value(i) = {0, -x};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -4) {</div>
<div class="line">        <span class="keywordtype">double</span> x = domain.pos(i, 0);</div>
<div class="line">        op.value(i) = {x*x, 0};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Sparse solve</span></div>
<div class="line">    Eigen::BiCGSTAB&lt;Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt;&gt; solver;</div>
<div class="line">    solver.compute(<a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>);</div>
<div class="line">    Eigen::VectorXd sol = solver.solve(<a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; ++i) {</div>
<div class="line">        <a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a> correct = analytical(domain.pos(i));</div>
<div class="line">        ASSERT_NEAR(sol[i], correct[0], 1e-3);</div>
<div class="line">        ASSERT_NEAR(sol[i+N], correct[1], 1e-3);</div>
<div class="line">    }</div>
<div class="ttc" id="aclassmm_1_1FindClosest_html"><div class="ttname"><a href="classmm_1_1FindClosest.html">mm::FindClosest</a></div><div class="ttdoc">Class representing the engine for finding supports consisting of closest nodes.</div><div class="ttdef"><b>Definition</b> <a href="FindClosest__fwd_8hpp_source.html#l00023">FindClosest_fwd.hpp:23</a></div></div>
<div class="ttc" id="anamespacemm_html_a3cf09fb5c30d93f0cfb30d80f0b8c6cf"><div class="ttname"><a href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">mm::Vec2d</a></div><div class="ttdeci">Vec&lt; double, 2 &gt; Vec2d</div><div class="ttdoc">Convenience typedef for 2d vector of doubles.</div><div class="ttdef"><b>Definition</b> <a href="Vec__fwd_8hpp_source.html#l00034">Vec_fwd.hpp:34</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00465">465</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="af3c0c65935c24c516113009c7cd344be" name="af3c0c65935c24c516113009c7cd344be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c0c65935c24c516113009c7cd344be">&#9670;&#160;</a></span>graddiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradDivOp.html">GradDivOp</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::graddiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ad437ada41a213bed7bbd8799a889dc9f">graddiv</a> with row equal to current node. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00488">488</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="ad437ada41a213bed7bbd8799a889dc9f" name="ad437ada41a213bed7bbd8799a889dc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad437ada41a213bed7bbd8799a889dc9f">&#9670;&#160;</a></span>graddiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradDivOp.html">GradDivOp</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::graddiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets implicit equation that gradient of divergence of a vector field is equal to some other value. </p>
<p>The code <code>alpha*op.graddiv(node) = v</code> fills the <code>node</code>-th, <code>node+N</code>-th and <code>node+2*N</code>-th row of matrix <code>M</code> these rows of equation \( M u = v \) are a good approximation of the equation </p><p class="formulaDsp">
\[ \alpha \nabla(\nabla \cdot \vec{u})(p) = \vec{v}(p), \]
</p>
<p> where \(p\) is the <code>node</code>-th point.</p>
<dl class="section note"><dt>Note</dt><dd>Above example was made for <code>dim = 3</code>, other dimensions are analogous. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Index of a node from 0 to <code>N</code> for which to write the equation for. This means only <code>node</code>-th<code>, node+N</code>-th and <code>node+2*N</code>-th rows of the matrix are changed. User must make sure that the matrix is large enough. </td></tr>
    <tr><td class="paramname">row</td><td>Write equation in this specific row. Row with index <code>node</code> is chosen by default.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">    <span class="comment">// Solve problem for u unknown vector field:</span></div>
<div class="line">    <span class="comment">// grad div u + laplace u = (2 + 4xy - 8pi^2sin(2*pi*x), 2(2x^2+y^2))</span></div>
<div class="line">    <span class="comment">// on [0, 1] x [0, 1] with BC:</span></div>
<div class="line">    <span class="comment">// u(0, y) = (y^2, 0)</span></div>
<div class="line">    <span class="comment">// u(1, y) = (y^2, y^2)</span></div>
<div class="line">    <span class="comment">// u(x, 0) = (sin(2*pi*x), 0)</span></div>
<div class="line">    <span class="comment">// u(x, 1) = (1+sin(2*pi*x, x^2)</span></div>
<div class="line">    <span class="comment">// with solution:</span></div>
<div class="line">    <span class="comment">// u(x, y) = (y^2 + sin(2*pi*x), x^2y^2)</span></div>
<div class="line">    std::function&lt;<a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a>(<a class="code hl_class" href="classmm_1_1Gaussian.html">Vec2d</a>)&gt; <a class="code hl_class" href="classmm_1_1Gaussian.html">analytical</a> = [] (<span class="keyword">const</span> <a class="code hl_class" href="classmm_1_1Gaussian.html">Vec2d</a>&amp; p) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a>({p[1]*p[1]+std::sin(2*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*p[0]), p[0]*p[0]*p[1]*p[1]});</div>
<div class="line">    };</div>
<div class="line">    <span class="comment">// Prepare domain</span></div>
<div class="line">    BoxShape&lt;Vec2d&gt; box(0., 1.);</div>
<div class="line">    DomainDiscretization&lt;Vec2d&gt; domain = box.discretizeWithStep(0.025);</div>
<div class="line">    <span class="keywordtype">int</span> N = domain.size();</div>
<div class="line">    <span class="keywordtype">int</span> support_size = 6;</div>
<div class="line">    domain.findSupport(FindClosest(support_size));</div>
<div class="line">    <span class="comment">// Prepare operators and matrix</span></div>
<div class="line">    WLS&lt;Monomials&lt;Vec2d&gt;, GaussianWeight&lt;Vec2d&gt;&gt; wls(2, std::sqrt(15.0 / N));</div>
<div class="line">    <span class="keyword">auto</span> storage = domain.computeShapes&lt;<a class="code hl_variable" href="namespacemm_1_1sh.html#a60b0e1ba4d8f14cf84bd2e385816e6bd">sh::graddiv</a>|<a class="code hl_variable" href="namespacemm_1_1sh.html#a434ea4fc68d98db4d13d50adf7915ac0">sh::lap</a>&gt;(wls, domain.interior());</div>
<div class="line"> </div>
<div class="line">    Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt; <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>(2*N, 2*N);</div>
<div class="line">    <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>.reserve(Range&lt;int&gt;(2*N, support_size));</div>
<div class="line">    Eigen::VectorXd <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>(2*N); <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>.setZero();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> op = storage.implicitVectorOperators(<a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>, <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>);</div>
<div class="line">    <span class="comment">// Set equation on interior</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.interior()) {</div>
<div class="line">        <span class="keywordtype">double</span> x = domain.pos(i, 0), y = domain.pos(i, 1);</div>
<div class="line">        op.lap(i) + op.graddiv(i) = {2+4*x*y-8*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*std::sin(2*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*x), 2*(2*x*x + y*y)};</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Set boundary conditions</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -1) {</div>
<div class="line">        <span class="keywordtype">double</span> y = domain.pos(i, 1);</div>
<div class="line">        op.value(i) = {y*y, 0};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -2) {</div>
<div class="line">        <span class="keywordtype">double</span> y = domain.pos(i, 1);</div>
<div class="line">        op.value(i) = {y*y, y*y};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -3) {</div>
<div class="line">        <span class="keywordtype">double</span> x = domain.pos(i, 0);</div>
<div class="line">        op.value(i) = {std::sin(2*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*x), 0};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -4) {</div>
<div class="line">        <span class="keywordtype">double</span> x = domain.pos(i, 0);</div>
<div class="line">        op.value(i) = {1+std::sin(2*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*x), x*x};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Sparse solve</span></div>
<div class="line">    Eigen::BiCGSTAB&lt;Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt;&gt; solver;</div>
<div class="line">    solver.compute(<a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>);</div>
<div class="line">    Eigen::VectorXd sol = solver.solve(<a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; ++i) {</div>
<div class="line">        <a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a> correct = analytical(domain.pos(i));</div>
<div class="line">        EXPECT_NEAR(sol[i], correct[0], 0.8e-2);</div>
<div class="line">        EXPECT_NEAR(sol[i+N], correct[1], 0.8e-2);</div>
<div class="line">    }</div>
<div class="ttc" id="anamespacemm_1_1sh_html_a434ea4fc68d98db4d13d50adf7915ac0"><div class="ttname"><a href="namespacemm_1_1sh.html#a434ea4fc68d98db4d13d50adf7915ac0">mm::sh::lap</a></div><div class="ttdeci">static const shape_flags lap</div><div class="ttdoc">Indicates to calculate laplace shapes.</div><div class="ttdef"><b>Definition</b> <a href="shape__flags_8hpp_source.html#l00024">shape_flags.hpp:24</a></div></div>
<div class="ttc" id="anamespacemm_1_1sh_html_a60b0e1ba4d8f14cf84bd2e385816e6bd"><div class="ttname"><a href="namespacemm_1_1sh.html#a60b0e1ba4d8f14cf84bd2e385816e6bd">mm::sh::graddiv</a></div><div class="ttdeci">static const shape_flags graddiv</div><div class="ttdoc">Indicates to prepare all shapes needed for graddiv.</div><div class="ttdef"><b>Definition</b> <a href="shape__flags_8hpp_source.html#l00028">shape_flags.hpp:28</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00486">486</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="aaec7d8dc8bed3fe6674bbdb49a647be3" name="aaec7d8dc8bed3fe6674bbdb49a647be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec7d8dc8bed3fe6674bbdb49a647be3">&#9670;&#160;</a></span>hasMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">bool</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::hasMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if operators have a non-null pointer to problem matrix. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00363">363</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a90d2cfc7432e4446a58d2301a81cb705" name="a90d2cfc7432e4446a58d2301a81cb705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d2cfc7432e4446a58d2301a81cb705">&#9670;&#160;</a></span>hasRhs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">bool</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::hasRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if operators have a non-null pointer to problem right hand side. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00365">365</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a6fd7371d3d5b981ad081f80a7d614a62" name="a6fd7371d3d5b981ad081f80a7d614a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd7371d3d5b981ad081f80a7d614a62">&#9670;&#160;</a></span>hasShapes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">bool</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::hasShapes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if operators have a non-null pointer to storage and <code>false</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00361">361</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a4db926808f3261b109dd638e91a318a0" name="a4db926808f3261b109dd638e91a318a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db926808f3261b109dd638e91a318a0">&#9670;&#160;</a></span>lap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a>&lt; <a class="el" href="structmm_1_1Lap.html">Lap</a>&lt; <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a1b564fe24def4e4a7ffb72013b7ad80ca7ce70b5be9ed05376062f8e4f2b32a85">dim</a> &gt; &gt; <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::lap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a66a5ce2f46b81ed0512efd638720607c">lap</a> with row equal to current node. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00422">422</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a66a5ce2f46b81ed0512efd638720607c" name="a66a5ce2f46b81ed0512efd638720607c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a5ce2f46b81ed0512efd638720607c">&#9670;&#160;</a></span>lap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1BasicOp.html">BasicOp</a>&lt; <a class="el" href="structmm_1_1Lap.html">Lap</a>&lt; <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a1b564fe24def4e4a7ffb72013b7ad80ca7ce70b5be9ed05376062f8e4f2b32a85">dim</a> &gt; &gt; <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::lap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets implicit equation that Laplacian of a vector field is equal to some other value. </p>
<p>The code <code>alpha*op.lap(node) = v</code> fills the <code>node</code>-th, <code>node+N</code>-th and <code>node+2*N</code>-th row of matrix <code>M</code> these rows of equation \( M u = v \) are a good approximation of the equation </p><p class="formulaDsp">
\[ \alpha \nabla^2\vec{u}(p) = \vec{v}(p), \]
</p>
<p> where \(p\) is the <code>node</code>-th point.</p>
<dl class="section note"><dt>Note</dt><dd>Above example was made for <code>dim = 3</code>, other dimensions are analogous. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Index of a node from 0 to <code>N</code> for which to write the equation for. This means only <code>node</code>-th<code>, node+N</code>-th and <code>node+2*N</code>-th rows of the matrix are changed. User must make sure that the matrix is large enough. </td></tr>
    <tr><td class="paramname">row</td><td>Write equation in this specific row. Row with index <code>node</code> is chosen by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A class representing this operation for lazy evaluation purposes.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">    <span class="comment">// Solve problem for F unknown vector field:</span></div>
<div class="line">    <span class="comment">// (Laplace F)(x, y) = [4 (1 - 2 pi^2 y^2) sin(2 pi x); 4 (1 - x - x y) e^(2 y)]</span></div>
<div class="line">    <span class="comment">// on [0, 1] x [0, 1] with BC:</span></div>
<div class="line">    <span class="comment">// F(x, 0) = [0, 1]</span></div>
<div class="line">    <span class="comment">// F(x, 1) = [2 sin(2 pi x), (1 - x) e^2]</span></div>
<div class="line">    <span class="comment">// F(0, y) = [0, e^(2 y)]</span></div>
<div class="line">    <span class="comment">// F(1, y) = [0, (1 - y) e^(2 y)]</span></div>
<div class="line">    <span class="comment">// with solution:</span></div>
<div class="line">    <span class="comment">// F(x, y) = [2 sin(2 pi x) y^2,  (1 - x y) e^(2 y)]</span></div>
<div class="line">    std::function&lt;<a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a>(<a class="code hl_class" href="classmm_1_1Gaussian.html">Vec2d</a>)&gt; <a class="code hl_class" href="classmm_1_1Gaussian.html">analytical</a> = [] (<span class="keyword">const</span> <a class="code hl_class" href="classmm_1_1Gaussian.html">Vec2d</a>&amp; p) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a>({2*std::sin(2*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*p[0])*p[1]*p[1],  (1 - p[0]*p[1]) * std::exp(2*p[1])});</div>
<div class="line">    };</div>
<div class="line">    <span class="comment">// Prepare domain</span></div>
<div class="line">    BoxShape&lt;Vec2d&gt; box(0., 1.);</div>
<div class="line">    DomainDiscretization&lt;Vec2d&gt; domain = box.discretizeWithStep(0.025);</div>
<div class="line">    <span class="keywordtype">int</span> N = domain.size();</div>
<div class="line">    <span class="keywordtype">int</span> support_size = 9;</div>
<div class="line">    domain.findSupport(FindClosest(support_size));</div>
<div class="line">    <span class="comment">// Prepare operators and matrix</span></div>
<div class="line">    WLS&lt;Monomials&lt;Vec2d&gt;, GaussianWeight&lt;Vec2d&gt;&gt; wls(2, std::sqrt(15.0 / N));</div>
<div class="line">    <span class="keyword">auto</span> storage = domain.computeShapes(wls);</div>
<div class="line">    Eigen::SparseMatrix&lt;double&gt; <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>(2*N, 2*N);</div>
<div class="line">    <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>.reserve(storage.supportSizes()+storage.supportSizes());</div>
<div class="line">    Eigen::VectorXd <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>(2*N); <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>.setZero();</div>
<div class="line">    <span class="keyword">auto</span> op = storage.implicitVectorOperators(<a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>, <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>);</div>
<div class="line">    <span class="comment">// Set equation on interior</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.interior()) {</div>
<div class="line">        <span class="keywordtype">double</span> x = domain.pos(i, 0), y = domain.pos(i, 1);</div>
<div class="line">        op.lap(i) = {4 * (1 - 2 * <a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a>*<a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a> * y*y) * std::sin(2 * <a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a> * x),</div>
<div class="line">                     4 * (1 - x - x * y) * std::exp(2 * y)};</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Set boundary conditions</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -1) {</div>
<div class="line">        <span class="keywordtype">double</span> y = domain.pos(i, 1);</div>
<div class="line">        op.value(i) = {0, std::exp(2*y)};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -2) {</div>
<div class="line">        <span class="keywordtype">double</span> y = domain.pos(i, 1);</div>
<div class="line">        op.value(i) = {0, (1-y) * std::exp(2*y)};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -3) {</div>
<div class="line">        op.value(i) = {0, 1};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : domain.types() == -4) {</div>
<div class="line">        <span class="keywordtype">double</span> x = domain.pos(i, 0);</div>
<div class="line">        op.value(i) = {2 * std::sin(2 * <a class="code hl_variable" href="namespacemm.html#add5120ca222cb67674865bb4ea92cfae">PI</a> * x), (1 - x) * std::exp(2)};</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Sparse solve</span></div>
<div class="line">    <a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>.makeCompressed();</div>
<div class="line"> </div>
<div class="line">    Eigen::SparseLU&lt;Eigen::SparseMatrix&lt;double&gt;&gt; solver;</div>
<div class="line">    solver.compute(<a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>);</div>
<div class="line">    Eigen::VectorXd sol = solver.solve(<a class="code hl_variable" href="classmm_1_1ImplicitVectorOperators.html#a2d458b9fb8127458854493459927b6ad">rhs</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; ++i) {</div>
<div class="line">        <a class="code hl_typedef" href="namespacemm.html#a3cf09fb5c30d93f0cfb30d80f0b8c6cf">Vec2d</a> correct = analytical(domain.pos(i));</div>
<div class="line">        EXPECT_NEAR(sol[i], correct[0], 1e-3);</div>
<div class="line">        EXPECT_NEAR(sol[N+i], correct[1], 1e-3);</div>
<div class="line">    }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00420">420</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a6d480d361d6e245fc76ecaf1f954a473" name="a6d480d361d6e245fc76ecaf1f954a473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d480d361d6e245fc76ecaf1f954a473">&#9670;&#160;</a></span>neumann() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradOp.html">GradOp</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::neumann </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#afa6dfabbc7847f1ca0230c0baaf89e6f">neumann</a> with row equal to current node. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00511">511</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="afa6dfabbc7847f1ca0230c0baaf89e6f" name="afa6dfabbc7847f1ca0230c0baaf89e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6dfabbc7847f1ca0230c0baaf89e6f">&#9670;&#160;</a></span>neumann() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1GradOp.html">GradOp</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::neumann </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets neumann boundary conditions in node <code>node</code>. </p>
<p>The code <code>alpha*op.neumann(node, normal) = v</code> fills the <code>node</code>-th, <code>node+N</code>-th and <code>node+2*N</code>-th row of matrix <code>M</code> these rows of equation \( M u = v \) are a good approximation of the equation </p><p class="formulaDsp">
\[ \alpha \dpar{\vec{u}}{\vec{n}}(p) = \vec{v}(p) \]
</p>
<p> where \(p\) is the <code>node</code>-th point and \(\vec{n}\) is the <code>unit_normal</code>.</p>
<p>This is the same as using <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4cdbc9c84f3bd59ad70a848f9a154ad8" title="Sets implicit equation that gradient of a vector field along v is equal to some other value.">grad()</a>, but has additional semantic meaning of setting the boundary conditions.</p>
<dl class="section return"><dt>Returns</dt><dd>A class representing this operation for lazy evaluation purposes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4cdbc9c84f3bd59ad70a848f9a154ad8" title="Sets implicit equation that gradient of a vector field along v is equal to some other value.">grad</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00505">505</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a5f6244d56fb91a7764fa910be0dae478" name="a5f6244d56fb91a7764fa910be0dae478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6244d56fb91a7764fa910be0dae478">&#9670;&#160;</a></span>setColOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">void</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::setColOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>col_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets col offset for given matrix, treating it as is the first column had index <code>col_offset</code>. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00355">355</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="aa905c9aca385362d817892645df02662" name="aa905c9aca385362d817892645df02662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa905c9aca385362d817892645df02662">&#9670;&#160;</a></span>setProblem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">void</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::setProblem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2404465cccd97faba3cbd969ec3ded24">matrix_t</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a305217f7605dae34ae19a1c0ba48e6f1">rhs_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>row_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>col_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets current matrix and right hand side. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00343">343</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a982f91b629f8ede36242eafff90af2e8" name="a982f91b629f8ede36242eafff90af2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982f91b629f8ede36242eafff90af2e8">&#9670;&#160;</a></span>setRowOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">void</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::setRowOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>row_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets row offset for given matrix, treating it as is the first row had index <code>row_offset</code>. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00350">350</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="ad25a0b1d0704d6e81ed3ab1a3e6e01cf" name="ad25a0b1d0704d6e81ed3ab1a3e6e01cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25a0b1d0704d6e81ed3ab1a3e6e01cf">&#9670;&#160;</a></span>traction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1TractionOp.html">TractionOp</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::traction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a>&#160;</td>
          <td class="paramname"><em>lam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a>&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ac9c2a73830aa60865f6f4fb0a8220345">traction</a> with row equal to current node. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00539">539</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="ac9c2a73830aa60865f6f4fb0a8220345" name="ac9c2a73830aa60865f6f4fb0a8220345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c2a73830aa60865f6f4fb0a8220345">&#9670;&#160;</a></span>traction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1TractionOp.html">TractionOp</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::traction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a>&#160;</td>
          <td class="paramname"><em>lam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a0b7736515f1b8c962dbdb49ad3e54fb7">scalar_t</a>&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ab47859ef66ea0612c1b2a3e421b01288">domain_vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>unit_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets traction boundary conditions in node <code>node</code>. </p>
<p>The code <code>alpha*op.traction(node, lam, mu, normal) = t</code> fills the <code>node</code>-th, <code>node+N</code>-th and <code>node+2*N</code>-th row of matrix <code>M</code> these rows of equation \( M u = t \) are a good approximation of the equation </p><p class="formulaDsp">
\[ \alpha (\sigma(\vec{u}) \vec{n}) (p) = \vec{t}(p) \]
</p>
<p> where \(p\) is the <code>node</code>-th point, \(\sigma\) is the stress tensor and \(\vec{n}\) is the <code>unit_normal</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Index of a node from 0 to <code>N</code> for which to write the equation for. This means only <code>node</code>-th<code>, node+N</code>-th and <code>node+2*N</code>-th rows of the matrix are changed. User must make sure that the matrix is large enough. </td></tr>
    <tr><td class="paramname">row</td><td>Write equation in this specific row. Row with index <code>node</code> is chosen by default. </td></tr>
    <tr><td class="paramname">lam</td><td>The first Lame coefficient. </td></tr>
    <tr><td class="paramname">mu</td><td>The second Lame coefficient. </td></tr>
    <tr><td class="paramname">unit_normal</td><td>The outside unit normal on the surface for which to set the traction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A class representing this operation for lazy evaluation purposes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00532">532</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a0682dcb439ee9d5bef2396f2fd450b36" name="a0682dcb439ee9d5bef2396f2fd450b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0682dcb439ee9d5bef2396f2fd450b36">&#9670;&#160;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1ValueOp.html">ValueOp</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classmm_1_1ImplicitVectorOperators.html#aa5fb8c89362488f19c74151e89d0f062">value</a> with row equal to current node. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00398">398</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="aa5fb8c89362488f19c74151e89d0f062" name="aa5fb8c89362488f19c74151e89d0f062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fb8c89362488f19c74151e89d0f062">&#9670;&#160;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators_1_1ValueOp.html">ValueOp</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets implicit equation that value of a vector field is equal to some other value. </p>
<p>The code <code>alpha*op.value(node) = v</code> fills the <code>node</code>-th, <code>node+N</code>-th and <code>node+2*N</code>-th row of matrix <code>M</code> these rows of equation \( M u = v \) are a good approximation of the equation </p><p class="formulaDsp">
\[ \alpha \vec{u}(p) = \vec{v}(p), \]
</p>
<p> where \(p\) is the <code>node</code>-th point.</p>
<dl class="section note"><dt>Note</dt><dd>Above example was made for <code>dim = 3</code>, other dimensions are analogous. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Index of a node from 0 to <code>N</code> for which to write the equation for. This means only <code>node</code>-th<code>, node+N</code>-th and <code>node+2*N</code>-th rows of the matrix are changed. User must make sure that the matrix is large enough. </td></tr>
    <tr><td class="paramname">row</td><td>Write equation in this specific row. Row with index <code>node</code> is chosen by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A class representing this operation for lazy evaluation purposes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00396">396</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a51a52afff676957599c7a6db586e113d" name="a51a52afff676957599c7a6db586e113d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a52afff676957599c7a6db586e113d">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">S</a> , <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a> , <a class="el" href="classmm_1_1Gaussian.html">typename</a> <a class="el" href="classmm_1_1Gaussian.html">R</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classmm_1_1Gaussian.html">operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">S</a>, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#ae9519c74815de424a5d88b097b677f87">M</a>, <a class="el" href="classmm_1_1Gaussian.html">R</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output basic info about given operators. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators_8hpp_source.html#l00043">43</a> of file <a class="el" href="ImplicitVectorOperators_8hpp_source.html">ImplicitVectorOperators.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a143aade67b6261190c42ab7857290c81" name="a143aade67b6261190c42ab7857290c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143aade67b6261190c42ab7857290c81">&#9670;&#160;</a></span>col_offset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::col_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Column offset to be used when accessing matrix coefficients. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00065">65</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="ae9519c74815de424a5d88b097b677f87" name="ae9519c74815de424a5d88b097b677f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9519c74815de424a5d88b097b677f87">&#9670;&#160;</a></span>M</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a2404465cccd97faba3cbd969ec3ded24">matrix_t</a>* <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::M</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to problem matrix. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00062">62</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="a2d458b9fb8127458854493459927b6ad" name="a2d458b9fb8127458854493459927b6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d458b9fb8127458854493459927b6ad">&#9670;&#160;</a></span>rhs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1ImplicitVectorOperators.html#a305217f7605dae34ae19a1c0ba48e6f1">rhs_t</a>* <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::rhs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to right hand side. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00063">63</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="ae7bb6d892277faabf4841119ab416a76" name="ae7bb6d892277faabf4841119ab416a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bb6d892277faabf4841119ab416a76">&#9670;&#160;</a></span>row_offset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">int</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::row_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Row offset to be used when accessing matrix or rhs coefficients. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00064">64</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<a id="acd44e9a6cc6c91978fa1eadb14071729" name="acd44e9a6cc6c91978fa1eadb14071729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd44e9a6cc6c91978fa1eadb14071729">&#9670;&#160;</a></span>ss</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a> , <a class="el" href="classmm_1_1Gaussian.html">class</a> <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmm_1_1Gaussian.html">const</a> <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a58618cbb858929ea0248bf61d52bbd98">shape_storage_t</a>* <a class="el" href="classmm_1_1ImplicitVectorOperators.html">mm::ImplicitVectorOperators</a>&lt; <a class="el" href="classmm_1_1Gaussian.html">shape_storage_type</a>, <a class="el" href="classmm_1_1Gaussian.html">matrix_type</a>, <a class="el" href="classmm_1_1Gaussian.html">rhs_type</a> &gt;::ss</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shape storage, but name is shortened for readability. </p>

<p class="definition">Definition at line <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html#l00061">61</a> of file <a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/medusa/bits/operators/<a class="el" href="ImplicitVectorOperators__fwd_8hpp_source.html">ImplicitVectorOperators_fwd.hpp</a></li>
<li>include/medusa/bits/operators/<a class="el" href="ImplicitVectorOperators_8hpp_source.html">ImplicitVectorOperators.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemm.html">mm</a></li><li class="navelem"><a class="el" href="classmm_1_1ImplicitVectorOperators.html">ImplicitVectorOperators</a></li>
    <li class="footer">Generated on Mon Oct 14 2024 16:54:48 for Medusa by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
