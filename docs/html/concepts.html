<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Medusa: Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Medusa"/>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      dpar: ["\\frac{\\partial #1}{\\partial #2}", 2]
    }
  }
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://e6.ijs.si/medusa/"><img alt="Logo" src="logo_transparent.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
    <div id="projectname">Medusa
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">Coordinate Free Mehless Method implementation</div>
  </td>
   <td id="ijslogo"><a href="http://e6.ijs.si/ParallelAndDistributedSystems/"><img src="logo_ijs.png" alt="IJS_logo"></a></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.php','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('concepts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Concepts</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Concepts are general patterns that certain classes follow or require their members to follow.</p>
<p>The most important ones are described below.</p>
<h1><a class="anchor" id="rbf-concept"></a>
Radial Basis Function concept</h1>
<p>This concept represents a radial basis function as a function of squared radial distance from the origin, ie. a function \(f\) mapping </p><p class="formulaDsp">
\[ r^2 \mapsto f(r^2) \]
</p>
<p>The only requirements are that the class is default constructible, has a <code>scalar_t</code> member type, that denotes the type used for numerical computations (eg. <code>double</code>) and has the operators:</p>
<ul>
<li><code>scalar_t operator()(scalar_t r2) const</code> evaluates function at given squared radial distance</li>
<li><code>scalar_t operator()(scalar_t r2, int derivative) const</code> evaluates given derivative wrt. <code>r2</code> at given squared radial distance</li>
<li><code>template &lt;int dim&gt; scalar_t operator()(scalar_t r2, <a class="el" href="structmm_1_1Lap.html" title="Represents the Laplacian operator.">Lap</a>&lt;dim&gt;) const</code> evaluates Laplacian wrt. <code>r</code> at given squared radial distance</li>
</ul>
<p>Classes <a class="el" href="classmm_1_1Gaussian.html" title="Gaussian Radial Basis Function.">Gaussian</a>, <a class="el" href="classmm_1_1Multiquadric.html" title="Multiquadric Radial Basis Function.">Multiquadric</a>, <a class="el" href="classmm_1_1InverseMultiquadric.html" title="Inverse Multiquadric Radial Basis Function.">InverseMultiquadric</a> and <a class="el" href="classmm_1_1Polyharmonic.html" title="Polyharmonic Radial Basis Function of odd order.">Polyharmonic</a> satisfy this concept.</p>
<h1><a class="anchor" id="scale-concept"></a>
Scale function concept</h1>
<p>This represents a scaling function that computes the appropriate scaling to the local support domain. It requires a class to implement a single method</p>
<ul>
<li><code>template&lt;vec_t&gt; static typename vec_t::scalar_t scale(const vec_t&amp; p, const std::vector&lt;vec_t&gt;&amp; support)</code></li>
</ul>
<p>which returns local scale of this neighbourhood. For a neighbourhood of <code>{0, -h, h}</code>, <code>h</code> would be the appropriate local scale. Support nodes are assumed to be ordered by distance from <code>p</code>.</p>
<p>Classes <a class="el" href="classmm_1_1NoScale.html" title="Scale function that indicates no scaling is performed.">NoScale</a>, <a class="el" href="classmm_1_1ScaleToClosest.html" title="Scale function that scales to the closest neighbor.">ScaleToClosest</a>, <a class="el" href="classmm_1_1ScaleToFarthest.html" title="Scale function that scales to the farthest neighbor.">ScaleToFarthest</a> satisfy this concept.</p>
<h1><a class="anchor" id="weight-concept"></a>
Weight function concept</h1>
<p>This concept represents a weight function used for weighted least squares solving. The function returns a non-negative scalar for all inputs.</p>
<p>Classes satisfying this concept must be default constructible and provide member types <code>scalar_t</code>, <code>vector_t</code>, and static value <code>dim</code>, representing types used for numerical computation, and dimensionality of the function domain. Additionally, this method must be provided:</p>
<ul>
<li><code>scalar_t operator()(const vector_t&amp; point) const</code></li>
</ul>
<p>which evaluates the weight function.</p>
<p>Classes <a class="el" href="classmm_1_1NoWeight.html" title="Class representing no weight function, i.e. a constant 1.">NoWeight</a> and <a class="el" href="classmm_1_1RBFWeight.html" title="Represents a weight function constructed from a Radial Basis function.">RBFWeight</a> satisfy this concept. Specific instance of <a class="el" href="classmm_1_1RBFWeight.html" title="Represents a weight function constructed from a Radial Basis function.">RBFWeight</a>, namely GaussianWeight is defined for <a class="el" href="classmm_1_1Gaussian.html" title="Gaussian Radial Basis Function.">Gaussian</a> RBFs, because of common usage.</p>
<h1><a class="anchor" id="basis-concept"></a>
Basis function concept</h1>
<p>This concept represents a (local or global) basis over a neighbourhood of points.</p>
<p>Classes satisfying this concept must be default constructible and provide member types <code>scalar_t</code>, <code>vector_t</code>, and static value <code>dim</code>, representing types used for numerical computation, and dimensionality of the function domain. Additionally, these four methods must be provided:</p>
<ul>
<li><code>scalar_t eval(int index, const vector_t&amp; point, const std::vector&lt;vector_t&gt;&amp; support) const</code></li>
<li><code>template &lt;typename operator_t&gt; scalar_t evalOp(int index, const vector_t&amp; point, const operator_t&amp; op, const std::vector&lt;vector_t&gt;&amp; support, scalar_t scale) const</code></li>
<li><code>scalar_t evalAt0(int index, const std::vector&lt;vector_t&gt;&amp; support) const;</code></li>
<li><code>template &lt;typename operator_t&gt; scalar_t evalOpAt0(int index, const operator_t&amp; op, const std::vector&lt;vector_t&gt;&amp; support) const;</code></li>
</ul>
<p>allowing evaluation of <code>i</code>-th basis member in given point or at 0 and arbitrary operators. The special methods for evaluation at 0 are commonly used in approximation computations and are usually simpler and faster than general methods, which are not needed in that case. Support nodes are assumed to be ordered by distance from <code>p</code>.</p>
<p>Classes <a class="el" href="classmm_1_1Monomials.html" title="A class representing Monomial basis.">Monomials</a> and <a class="el" href="classmm_1_1RBFBasis.html" title="Represents a basis of Radial Basis Functions over a local neighbourhood.">RBFBasis</a> satisfy this concept.</p>
<h1><a class="anchor" id="operator-family-concept"></a>
Operator family concept</h1>
<p>An operator family is a (finite) collection of operators. Each operator family must have an <code>operator_t</code> type, defining the type of operators in the family. For convenience when printing, methods <code>name</code> and <code>type_name</code> must be defined, giving human readable names. Additionally, a collection of all operators in the family must be available through <code>operators</code> method, its size is given by <code>size()</code>, and the index of an operator in this family can be computed using the <code>index</code> method.</p>
<p>In summary, the following methods must be defined:</p>
<ul>
<li><code>std::string name() const;</code></li>
<li><code>static int size();</code></li>
<li><code>static std::string type_name();</code></li>
<li><code>static std::array&lt;operator_t, size&gt; operators();</code> // can return other iterables</li>
<li><code>static int index(operator_t o);</code> // can take const &amp;</li>
</ul>
<p>The first four are used by <a class="el" href="group__operators.html#gaff43acf3e841f21a3e28c4348b9943b6">computeShapes</a> to compute approximations, while the last one is used by <a class="el" href="classmm_1_1ExplicitOperators.html" title="A class for evaluating typical operators needed in spatial discretization.">ExplicitOperators</a> and <a class="el" href="classmm_1_1ImplicitOperators.html" title="This class represents implicit operators that fill given matrix M and right hand side rhs with approp...">ImplicitOperators</a> to get the index of operator in storage. The <code>index</code> method must also be compatible with <code>operators</code>, in the sense that for the list of operators <code>o</code>, returned by <code>operators</code>, it must hold that <code>index(o[i]) == i</code> for each <code>i</code>, i.e. the operators must be given in order by the <code>operators</code> method.</p>
<p>The <a class="el" href="group__operators.html#gaff43acf3e841f21a3e28c4348b9943b6">computeShapes</a> method only computes approximations for families of operators, however, inheriting from the <code><a class="el" href="structmm_1_1Operator.html" title="Base class for a differential operator.">Operator</a></code> class will introduce all the required methods for 1-element families.</p>
<p>Classes <a class="el" href="structmm_1_1Der1s.html" title="Represents a family of all first derivatives.">Der1s</a>, <a class="el" href="structmm_1_1Der2s.html" title="Represents a family of all second derivatives.">Der2s</a>, <a class="el" href="structmm_1_1Lap.html" title="Represents the Laplacian operator.">Lap</a>, <a class="el" href="structmm_1_1Der1.html" title="Represents a first derivative wrt. var.">Der1</a>, <a class="el" href="structmm_1_1Der2.html" title="Represents a second derivative wrt. var1 and var2.">Der2</a>, <a class="el" href="structmm_1_1Derivative.html" title="Represents a general derivative .">Derivative</a>, Biharmonic satisfy this concept.</p>
<h1><a class="anchor" id="operator-concept"></a>
Operator concept</h1>
<p>This concept represents a (differential) operator, which can be applied to basis functions (see the <a class="el" href="concepts.html#basis-concept">Basis function concept</a> above) and for which approximations can be computed using approximation engines (see <a class="el" href="concepts.html#approx-concept">Approximation engine concept</a> below).</p>
<p>The basis itself can know how to compute the given operator, but if it does not, the appropriate one of two methods that are required by this concept will be implemented.</p>
<ul>
<li><code>template &lt;typename basis_t&gt; typename basis_t::scalar_t apply(
        const basis_t&amp; basis, int index, typename basis_t::vector_t point,
        const std::vector&lt;typename basis_t::vector_t&gt;&amp; support,
        typename basis_t::scalar_t scale) const;</code></li>
<li><code>template &lt;typename basis_t&gt; typename basis_t::scalar_t applyAt0(
        const basis_t&amp; basis, int index,
        const std::vector&lt;typename basis_t::vector_t&gt;&amp; support,
        typename basis_t::scalar_t scale) const;</code></li>
</ul>
<p>These methods should implement applying the operator to <code>i</code>-th member of the basis. Support nodes are assumed to be ordered by distance from the central point (<code>point</code> or <code>0</code>). See Operators class for more details. Additionally, the operator must define the <code>std::string name() const;</code> method for printing.</p>
<p>This allows implementation of custom operators in such a way, that if you only use <code>MQ</code> basis functions, you operator only need to know how to be applied specifically to <code>MQ</code> basis. Custom operator approximation can be obtained using <a class="el" href="classmm_1_1ShapeStorage.html#a7590640501f4258763e6b2dbe404ec67" title="Get the weight of j-th stencil node of node for operator op in op_family (by index).">ShapeStorage::get</a> and used with <a class="el" href="classmm_1_1ExplicitOperators.html#a80067a958aab068b1a851e3726ae87fa" title="Returns an approximation of applying the requested operator to field u at node node.">ExplicitOperators::apply</a>, <a class="el" href="classmm_1_1ImplicitOperators.html#aedcb630e4775c080a54209b172185b7a" title="Add the weights for operator o to the appropriate elements in the matrix.">ImplicitOperators::apply</a>, <a class="el" href="classmm_1_1ExplicitVectorOperators.html#ab59e210d9c8d912822fb8ce6ad2941d0" title="Returns an approximation of applying the requested operator to each component of field u at node node...">ExplicitVectorOperators::apply</a>, <a class="el" href="classmm_1_1ImplicitVectorOperators.html#a4aee2a76c9c66890e3c6e404e392839f" title="Add the weights for operator o to the appropriate elements in the matrix.">ImplicitVectorOperators::apply</a>.</p>
<h1><a class="anchor" id="approx-concept"></a>
Approximation engine concept</h1>
<p>This concept represents an approximation engine for approximating differential operators in neighborhood of points.</p>
<p>Given a point \(p\) with neighbours \(p_1, \dots, p_n\), called <em>support</em>, an operator \(\mathcal{L}\) is approximated as </p><p class="formulaDsp">
\[ (\mathcal{L}{u})(p) \approx \sum_{i=1}^n w_i u(p_i). \]
</p>
<p> The weights \(w_i\) are called stencil weights of the <em>shape function</em> for operator \(\mathcal{L}\) at points \(p\).</p>
<p>Approximation engines are classes that compute operator and function approximations. <a class="el" href="structmm_1_1Operator.html" title="Base class for a differential operator.">Operator</a> approximations are often called "stencil weights" or "shape function". They must provide member types <code>scalar_t</code> and <code>vector_t</code>, and static value <code>dim</code>, representing types used for numerical computation and dimensionality of the function domain. Additionally, these three methods must be provided:</p>
<ul>
<li><code>void compute(const vector_t&amp; point, const std::vector&lt;vector_t&gt;&amp; support)</code>,</li>
<li><code>Eigen::Matrix&lt;scalar_t, Eigen::Dynamic, 1&gt; getShape() const</code> and</li>
<li><code>template &lt;operator_t&gt; Eigen::Matrix&lt;scalar_t, Eigen::Dynamic, 1&gt; getShape(const operator_t&amp; op) const</code></li>
<li><code>FunctionType getApproximant(const vector_t&amp; point, const std::vector&lt;vector_t&gt;&amp; support, const Eigen::MatrixBase&lt;Derived&gt;&amp; values) const</code></li>
</ul>
<p>The compute step prepares the engine for approximation of operators around point <code>point</code> with given support <code>support</code> and is usually computationally more intense. Support nodes are assumed to be ordered by distance from <code>point</code>. The <code>getShape()</code> step computes the shape for given basic differential operator or the evaluation operator (first overload). The <code>getApproximant</code> method returns the function approximant around given point.</p>
<p>Typical usage is illustrated below: </p><div class="fragment"><div class="line">ApproximationEngine engine(...);</div>
<div class="line"><span class="keywordtype">double</span> h = 0.1;</div>
<div class="line">engine.compute({0.0, 0.0}, {{0.0, 0.0}, {-h, 0.0}, {h, 0.0}, {0.0, h}, {0.0, -h}});</div>
<div class="line">VectorXd shape = engine.getShape();</div>
<div class="line">VectorXd shape = engine.getShape(Lap());  <span class="comment">// shape for Laplacian</span></div>
</div><!-- fragment --><p>Classes <a class="el" href="classmm_1_1WLS.html" title="A class for generating approximations using Weighted Least Squares over local neighborhoods.">WLS</a> and <a class="el" href="classmm_1_1RBFFD.html" title="Computes a RBF-FD approximation of given operator over local neighbourhood.">RBFFD</a> satisfy this concept.</p>
<h1><a class="anchor" id="ss-concept"></a>
Shape storage concept</h1>
<p>This concept represents classes used for storing computed shape functions for different domain nodes. Their intention os to store the shape functions more compactly than if stored in <code>vector&lt;vector&lt;double&gt;&gt;</code>.</p>
<p>Classes <a class="el" href="classmm_1_1UniformShapeStorage.html" title="Efficiently stores shape functions of uniform length.">UniformShapeStorage</a> and <a class="el" href="classmm_1_1RaggedShapeStorage.html" title="Efficiently stores shape functions of different lengths.">RaggedShapeStorage</a> satisfy this concept. See also <a class="el" href="classmm_1_1ShapeStorage.html" title="Shape storage base class.">ShapeStorage</a> for CRTP inheritable interface.</p>
<p>Typical usage: </p><div class="fragment"><div class="line">    UniformShapeStorage&lt;Vec3d, std::tuple&lt;Lap&lt;3&gt;, Der1s&lt;3&gt;&gt;&gt; storage;</div>
<div class="line">    Range&lt;int&gt; sizes = {5, 5, 5, 5, 5, 5};</div>
<div class="line">    storage.resize(sizes);</div>
<div class="line"> </div>
<div class="line">    storage.size();  <span class="comment">// 6</span></div>
<div class="line">    Eigen::VectorXd lap(5);</div>
<div class="line">    lap &lt;&lt; 1.2, 3.4, 5.6, 7.8, 9.0;  <span class="comment">// compute the shapes</span></div>
<div class="line">    storage.setLaplace(2, lap);  <span class="comment">// set lap as laplace shape for node 2.</span></div>
<div class="line"> </div>
<div class="line">    storage.laplace(2, 3);  <span class="comment">// returns 7.8</span></div>
<div class="line"> </div>
<div class="line">    storage.d1(1, 3);  <span class="comment">// d/dy shape in node 3 (returns 0, because it is not set yet)</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; storage &lt;&lt; std::endl;</div>
</div><!-- fragment --><h1><a class="anchor" id="linsolve-concept"></a>
Linear solver concept</h1>
<p>This class represents a linear solver and follows the Eigen's <a href="https://eigen.tuxfamily.org/dox/group__TutorialLinearAlgebra.html">Linear algebra and decompositions</a>. The linear solver class must be default constructible and have two methods</p>
<ul>
<li><code>void compute(const Matrix&amp; M)</code></li>
<li><code>Vector solve(const Vector&amp; rhs)</code></li>
</ul>
<p>The class <a class="el" href="classmm_1_1JacobiSVDWrapper.html" title="Extends Eigen&#39;s JacobiSVD to compute thin U and thin V by default.">JacobiSVDWrapper</a> and most Eigen's decompositions follow this concept. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 14 2024 16:54:48 for Medusa by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
